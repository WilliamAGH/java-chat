<!doctype html>
<!-- htmlhint attr-lowercase:false -->
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
    <title>Java Chat - Beautiful AI-Powered Java Learning</title>
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="icon" type="image/png" href="/favicon-196x196.png" sizes="196x196" />
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16" />
    <link rel="icon" type="image/png" href="/favicon-128.png" sizes="128x128" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="application-name" content="Java Chat"/>
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="msapplication-TileImage" content="/mstile-144x144.png" />
    <meta name="msapplication-square70x70logo" content="/mstile-70x70.png" />
    <meta name="msapplication-square150x150logo" content="/mstile-150x150.png" />
    <meta name="msapplication-wide310x150logo" content="/mstile-310x150.png" />
    <meta name="msapplication-square310x310logo" content="/mstile-310x310.png" />
    
    <!-- Mobile-specific meta tags -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="format-detection" content="telephone=no" />
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="/css/app.css?v=mobile-responsive" rel="stylesheet" />
    
</head>
<body>
    <div class="container">
        <!-- Dev Diagnostics: visible only on localhost -->
        <div id="devDiagnostics" class="dev-diagnostics" style="display: none;">
            <details class="dev-panel" id="devRawSsePanel">
                <summary>Raw SSE (dev)</summary>
                <pre id="rawSseText" class="dev-pre"></pre>
            </details>
            <details class="dev-panel" id="devRagPanel">
                <summary>RAG Retrieval Context (dev)</summary>
                <div id="ragContext" class="dev-rag"></div>
            </details>
        </div>
        <div id="chat" role="log" aria-live="polite" aria-label="Chat messages">
        </div>
        
        <!-- Action buttons container -->
        <div class="chat-actions">
            <button type="button" class="export-chat-btn" onclick="copyChat()" aria-label="Copy all messages" title="Copy all messages" style="display: none;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M15 2H9a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V6Z"></path>
                    <path d="M9 6h6a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V7a 1 1 0 0 1 1-1Z"></path>
                    <path d="M14 2v4a1 1 0 0 0 1 1h1"></path>
                    <path d="M8 12h8"></path>
                    <path d="M8 16h6"></path>
                </svg>
            </button>
            
            <button type="button" class="scroll-indicator" onclick="scrollToBottom()" aria-label="New messages below" title="New messages below" style="display: none;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="7 13 12 18 17 13"></polyline>
                    <polyline points="7 6 12 11 17 6"></polyline>
                </svg>
            </button>
        </div>
        
        
        <div class="input-area">
            <div class="input-row">
                <div class="input-wrapper">
                    <input 
                        id="q" 
                        class="input" 
                        placeholder="Ask about Java - try 'What are records?' or 'Explain pattern matching'"
                        data-placeholder-long="Ask about Java - try 'What are records?' or 'Explain pattern matching'"
                        data-placeholder-short="Ask about Java (e.g., records, pattern matching)"
                        aria-label="Enter your Java question"
                        autocomplete="off"
                        onkeypress="if(event.key==='Enter') ask()"
                    />
                    <button type="button" class="btn" onclick="ask()" id="askBtn" aria-label="Send question">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Theme Toggle Placeholder (kept for parity) -->
    <button type="button" class="theme-toggle" style="display:none" aria-hidden="true"></button>
    
    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="/js/markdown-utils.js"></script>
    
    <script>
        // Dev gating: show diagnostics only in local/dev (hostname OR dev ports OR ?dev)
        const __host = location.hostname;
        const __port = Number(location.port || (location.href.match(/:(\d+)/)?.[1] || (location.protocol === 'https:' ? 443 : 80)));
        const __isLocalHostName = (__host === 'localhost' || __host === '127.0.0.1' || __host === '::1');
        const __isDevPort = (__port >= 8085 && __port <= 8090);
        const __qs = new URLSearchParams(location.search);
        const __hasDevFlag = (__qs.has('dev') || __qs.has('debug'));
        const isLocalhost = (__isLocalHostName || __isDevPort || __hasDevFlag);
        function showDevDiagnosticsIfLocal() { 
            try { 
                console.debug('[dev-diag] host=%s port=%s isLocalHostName=%s isDevPort=%s hasDevFlag=%s => show=%s', __host, __port, __isLocalHostName, __isDevPort, __hasDevFlag, isLocalhost);
                if (!isLocalhost) return; 
                const dev = document.getElementById('devDiagnostics'); 
                if (dev) dev.style.display = 'block'; 
            } catch(_) {} 
        }

        // Generate unique session ID for this page load
        const sessionId = 'chat-' + Date.now() + '-' + Math.random().toString(36).substring(2, 15);
        console.log('Session ID:', sessionId);
        
        // Enhanced streaming with character-by-character animation
        class StreamingText {
            constructor(element, text, speed = 30) { this.element = element; this.text = text; this.speed = speed; this.index = 0; }
            async stream() { const cursor = document.createElement('span'); cursor.className = 'typing-cursor'; this.element.appendChild(cursor); for (let i = 0; i < this.text.length; i++) { const char = this.text[i]; const textNode = document.createTextNode(char); this.element.insertBefore(textNode, cursor); await this.delay(1000 / this.speed); } cursor.remove(); }
            delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        }
        
        async function ask() {
            const input = document.getElementById('q');
            const q = input.value.trim();
            if (!q) return;
            
            const chatEl = document.getElementById('chat');
            const askBtn = document.getElementById('askBtn');
            
            // User bubble
            const userBubble = document.createElement('div');
            userBubble.className = 'bubble user';
            userBubble.textContent = q;
            const userCopyBtn = document.createElement('button');
            userCopyBtn.className = 'message-copy-btn';
            userCopyBtn.setAttribute('aria-label', 'Copy message');
            userCopyBtn.title = 'Copy message';
            userCopyBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>`;
            userCopyBtn.onclick = () => copyMessage(q, userCopyBtn);
            userBubble.appendChild(userCopyBtn);
            chatEl.appendChild(userBubble);
            
            // Check if we should show scroll indicator after adding user message
            setTimeout(checkScrollIndicator, 50);
            
            
            input.value = '';
            askBtn.disabled = true;
            
            // Assistant bubble
            const assistantBubble = document.createElement('div');
            assistantBubble.className = 'bubble assistant';
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading-dots';
            loadingDiv.innerHTML = `
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
            `;
            assistantBubble.appendChild(loadingDiv);
            chatEl.appendChild(assistantBubble);
            // Don't auto-scroll - let user control their view
            
            try {
                // Reset dev panels per question and fetch RAG diagnostics
                if (isLocalhost) {
                    const rawEl = document.getElementById('rawSseText'); if (rawEl) rawEl.textContent = '';
                    const ragEl = document.getElementById('ragContext'); if (ragEl) ragEl.innerHTML = '';
                    renderRagDiagnostics(q).catch(() => {});
                }
                const response = await fetch('/api/chat/stream', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ sessionId: sessionId, latest: q }) });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                // Mark as streaming
                window.isStreaming = true;
                
                // Keep loading animation until first content chunk arrives
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'streaming-text';
                const cursor = document.createElement('span'); cursor.className = 'typing-cursor';
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullText = '';
                let buffer = '';
                // Accumulate per SSE event (all data: lines until blank line)
                let eventBuf = '';
                let hasEventData = false;
                // Debounced rendering: reduce /api/markdown/render churn and jitter
                let renderTimer = null; let lastRendered = '';
                let firstChunk = false;
                
                const flushRender = async () => { 
                    try { 
                        if (fullText === lastRendered) return; 
                        
                        // Remove loading animation on first content chunk
                        if (!firstChunk && fullText.trim()) {
                            firstChunk = true;
                            loadingDiv.remove();
                            assistantBubble.appendChild(contentWrapper);
                            contentWrapper.appendChild(cursor);
                        }
                        
                        const formatted = await formatText(fullText); 
                        
                        // SMART UPDATE: Only update if content actually changed
                        // This prevents flickering from redundant DOM replacements
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = formatted;
                        
                        // Enhance BEFORE inserting to avoid flicker
                        try {
                            enhanceServerHtml(tempDiv);
                        } catch (err) {
                            console.debug('enhanceServerHtml error (non-critical):', err);
                        }
                        
                        // Now check if the enhanced HTML is actually different
                        if (tempDiv.innerHTML !== contentWrapper.innerHTML) {
                            contentWrapper.innerHTML = tempDiv.innerHTML;
                            
                            try {
                                attachCodeCopyButtons(contentWrapper);
                            } catch (err) {
                                console.debug('attachCodeCopyButtons error (non-critical):', err);
                            }
                            
                            // Apply syntax highlighting only to new content
                            try { 
                                if (window.Prism) {
                                    // Only highlight unhighlighted code blocks
                                    const unhighlighted = contentWrapper.querySelectorAll('pre code:not(.prism-highlighted)');
                                    unhighlighted.forEach(code => {
                                        Prism.highlightElement(code);
                                        code.classList.add('prism-highlighted');
                                    });
                                }
                            } catch (err) { 
                                console.debug('highlight error (non-critical):', err); 
                            }
                        }
                        // Update dev raw SSE panel with unformatted text
                        if (isLocalhost) {
                            const rawEl = document.getElementById('rawSseText'); if (rawEl) rawEl.textContent = fullText;
                        }
                        
                        // Re-add cursor after content updates (only if content wrapper is in DOM)
                        if (firstChunk) {
                            contentWrapper.appendChild(cursor);
                        }
                        
                        lastRendered = fullText; 
                        // Check if user is near bottom before auto-scrolling
                        const isNearBottom = chatEl.scrollHeight - chatEl.scrollTop - chatEl.clientHeight < 100;
                        if (isNearBottom) {
                            chatEl.scrollTop = chatEl.scrollHeight;
                        }
                        // Always check if indicator should be shown
                        checkScrollIndicator(); 
                    } catch(err){
                        console.error('flushRender error:', err);
                    } 
                };
                const scheduleRender = (immediate=false) => { if (immediate) { if (renderTimer) { clearTimeout(renderTimer); renderTimer=null; } flushRender(); } else { if (renderTimer) clearTimeout(renderTimer); renderTimer = setTimeout(flushRender, 120); } };
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        // Commit any in-flight SSE event at stream end
                        if (hasEventData) {
                            fullText += eventBuf;
                            eventBuf = '';
                            hasEventData = false;
                        }
                        break;
                    }
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;
                    const lines = buffer.split('\n');
                    buffer = lines[lines.length - 1];
                    for (let i = 0; i < lines.length - 1; i++) {
                        let line = lines[i];
                        if (line.endsWith('\r')) line = line.slice(0, -1);
                        // Skip SSE comments (keepalive etc.)
                        if (line.startsWith(':')) { continue; }
                        if (line.startsWith('data:')) {
                            // Preserve model whitespace EXACTLY as sent. Do not trim or strip
                            // leading spaces, since many providers (including OpenAI/GitHub
                            // Models) emit chunks that begin with a leading space to separate
                            // words across tokens. Removing it causes word concatenation.
                            // Per SSE spec, senders may optionally include a single space
                            // after the colon for readability, but since our server does not
                            // insert that space, we must not strip anything here.
                            let data = line.slice(5);
                            // Skip [DONE] token
                            if (data === '[DONE]') {
                                continue;
                            }
                            // Accumulate within the current SSE event; join multiple data lines with a newline
                            if (hasEventData) { eventBuf += '\n'; }
                            eventBuf += data;
                            hasEventData = true;
                            // Dev: update raw SSE panel incrementally so it's never empty
                            if (isLocalhost) { const rawEl = document.getElementById('rawSseText'); if (rawEl) rawEl.textContent = fullText + eventBuf; }
                        } else if (line.trim() === '') {
                            // Blank line marks the end of an SSE event; commit accumulated data
                            if (hasEventData) {
                                fullText += eventBuf;
                                eventBuf = '';
                                hasEventData = false;
                                if (isLocalhost) { const rawEl = document.getElementById('rawSseText'); if (rawEl) rawEl.textContent = fullText; }
                            }
                        }
                        // Client-side DIAG: log first few frames safely
                        if (i < 4 && line) {
                            try { console.debug('[DIAG] SSE line', line.slice(0, 160)); } catch(_) {}
                        }
                    }
                    // Drop terminal DONE frames if received (defense-in-depth)
                    if (fullText.trim() === '[DONE]') {
                        fullText = '';
                    }
                    // Decide whether to flush immediately based on sentence/paragraph/code boundaries
                    const immediate = window.MU ? MU.shouldImmediateFlush(fullText) : (/[.!?][\"')]*\s$/.test(fullText.slice(-4)) || /\n\n/.test(fullText.slice(-2)) || fullText.endsWith('```\n'));
                    scheduleRender(immediate);
                    if (firstChunk) {
                        try { window.parent.postMessage({ type: 'content-started' }, '*'); } catch(_){}
                    }
                    // Check scroll indicator during streaming
                    if (typeof checkScrollIndicator === 'function') {
                        checkScrollIndicator();
                    }
                }
                // Final flush
                await flushRender();
                cursor.remove();
                
                // Streaming complete
                window.isStreaming = false;
                // Check if indicator should still be shown
                checkScrollIndicator();
                
                const assistantCopyBtn = document.createElement('button');
                assistantCopyBtn.className = 'message-copy-btn';
                assistantCopyBtn.setAttribute('aria-label', 'Copy assistant response');
                assistantCopyBtn.title = 'Copy assistant response';
                assistantCopyBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>`;
                assistantCopyBtn.onclick = () => copyMessage(fullText, assistantCopyBtn);
                assistantBubble.appendChild(assistantCopyBtn);
                Prism.highlightAllUnder(assistantBubble);
                attachCodeCopyButtons(assistantBubble);
                await loadCitations(q, assistantBubble);
                await loadEnrichment(q, assistantBubble);
                
                // CRITICAL: Clean up any empty elements that might create visual artifacts
                cleanupEmptyElements(chatEl);
                
                // Show the copy all button after all processing is complete
                const exportBtn = document.querySelector('.export-chat-btn');
                if (exportBtn) {
                    // Wait a bit more to ensure everything is settled
                    setTimeout(() => {
                        exportBtn.style.display = 'flex';
                        setTimeout(() => {
                            exportBtn.classList.add('visible');
                        }, 50);
                    }, 500);
                }
            } catch (error) {
                console.error('Streaming error:', error);
                assistantBubble.innerHTML = `<div style="color: var(--accent-error);">⚠️ Error: Failed to get response. Please try again.</div>`;
            } finally { askBtn.disabled = false; input.focus(); }
        }
        
        /**
         * ENHANCED: AST-based markdown rendering with structured data support.
         * Uses the new UnifiedMarkdownService for AGENTS.md compliant processing.
         * Falls back to legacy processing if needed for backward compatibility.
         * 
         * @param {string} text - The markdown text to process
         * @param {boolean} useStructured - Whether to use the new structured endpoint
         * @param {boolean} useServerMarkdown - Whether to use server-side processing
         * @returns {Promise<string>} - Processed HTML content
         */
        async function formatText(text, useStructured = true, useServerMarkdown = true) {
            // NOTE: We removed the HTML detection check because streaming responses from GPT-5
            // come as raw markdown text and need processing. The MarkdownStreamProcessor
            // is only used for special cases, not the main streaming path.
            
            if (useServerMarkdown) {
                // Try the new structured endpoint first for better processing
                if (useStructured) {
                    try {
                        const response = await fetch('/api/markdown/render/structured', { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify({ content: text }) 
                        });
                        if (response.ok) { 
                            const data = await response.json();
                            console.debug('AST-based processing:', {
                                citations: data.citations?.length || 0,
                                enrichments: data.enrichments?.length || 0,
                                processingTime: data.processingTimeMs,
                                isClean: data.isClean
                            });
                            // Server already renders enrichment cards; apply client-side link pills and styling only
                            return applyCustomEnrichments(data.html); 
                        }
                        console.warn('Structured markdown failed, falling back to legacy:', response.status);
                    } catch (error) { 
                        console.warn('Structured markdown error, falling back to legacy:', error); 
                    }
                }
                
                // Fallback to legacy endpoint (still uses new processStructured internally)
                try {
                    const response = await fetch('/api/markdown/render', { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ content: text }) 
                    });
                    if (response.ok) { 
                        const data = await response.json(); 
                        return applyCustomEnrichments(data.html); 
                    }
                    console.error('Server markdown failed with status:', response.status);
                } catch (error) { 
                    console.error('Server markdown error:', error); 
                }
            }
            // Safety net: preserve enrichments, do minimal client markdown, then restore and enrich
            const preserved = preserveEnrichments(text);
            let html = clientMarkdownFallback(preserved);
            if (window.MU && MU.hoistMarkerOnlyLines) html = MU.hoistMarkerOnlyLines(html);
            const restored = restoreEnrichments(html);
            return applyCustomEnrichments(restored);
        }
        
        function applyCustomEnrichments(text) {
            if (window.MU && MU.applyInlineEnrichments) {
                return MU.applyInlineEnrichments(text);
            }
            return text;
        }
        
        function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }

        /**
         * FALLBACK: Preserve custom enrichment blocks while client-side parsing.
         * Mirrors server placeholders in MarkdownService.preserveEnrichments().
         * Focus fixes on server first; keep placeholder format in sync with server.
         */
        function preserveEnrichments(text) {
            return text.replace(/\{\{(hint|reminder|background|example|warning):([\s\S]*?)\}\}/g, (m, t, c) => `ZZENRICHZ${t}ZSTARTZZZ${c}ZZENRICHZ${t}ZENDZZZ`);
        }
        /**
         * FALLBACK: Restore enrichment placeholders back to {{type:content}} after client parse.
         * Mirrors MarkdownService.restoreEnrichments(). Keep in sync with server format.
         */
        function restoreEnrichments(html) {
            return html.replace(/ZZENRICHZ(\w+)ZSTARTZZZ([\s\S]*?)ZZENRICHZ\1ZENDZZZ/g, (m, t, c) => `{{${t}:${c}}}`);
        }

        /**
         * Enhance server HTML with our beautiful formatting
         * Applied AFTER server markdown rendering to preserve our CSS styles
         */
        function enhanceServerHtml(container) {
            try {
                if (!container || typeof container.querySelectorAll !== 'function') {
                    console.debug('enhanceServerHtml: Invalid container, skipping');
                    return;
                }
                
                // 1. Enhance code blocks with language classes and proper structure
                const codeBlocks = container.querySelectorAll('pre');
                codeBlocks.forEach(pre => {
                    // Ensure proper structure for our CSS
                    const code = pre.querySelector('code');
                    if (code) {
                        // Add language class if missing
                        if (!code.className || !code.className.includes('language-')) {
                            const text = code.textContent || '';
                            // Auto-detect Java
                            if (text.includes('public class') || text.includes('import java') || 
                                text.includes('public static void') || text.includes('HashMap') ||
                                text.includes('String') || text.includes('System.out')) {
                                code.className = 'language-java';
                                pre.className = 'language-java';
                                pre.setAttribute('data-language', 'java');
                            }
                        } else if (code.className) {
                            // Copy language class to pre for our CSS
                            const langMatch = code.className.match(/language-(\w+)/);
                            if (langMatch) {
                                pre.className = `language-${langMatch[1]}`;
                                // Also set data attribute for CSS ::after content
                                pre.setAttribute('data-language', langMatch[1]);
                            }
                        }
                    }
                });
                
                // 2. Enhance lists - Server returns plain <ul>/<ol>, we need our styles
                const lists = container.querySelectorAll('ul, ol');
                lists.forEach(list => {
                    // Our CSS expects specific structure, server provides basic HTML
                    // No need to modify, our CSS handles it with proper selectors
                });
                
                // 3. Ensure inline code gets proper styling
                const inlineCodes = container.querySelectorAll('code:not(pre code)');
                inlineCodes.forEach(code => {
                    // Our CSS handles this with the code selector
                });
                
                // 4. Enhance strong/bold text
                const bolds = container.querySelectorAll('strong, b');
                bolds.forEach(bold => {
                    // Our CSS handles this with gradient text
                });
                
                console.debug(`enhanceServerHtml: Enhanced ${codeBlocks.length} code blocks, ${lists.length} lists`);
                
            } catch (err) {
                console.debug('enhanceServerHtml: Non-critical error', err);
            }
        }
        
        // Keep the old function for compatibility but make it call the new one
        function upgradeCodeBlocks(container) {
            enhanceServerHtml(container);
        }
        
        // Mobile-specific optimizations
        function initMobileOptimizations() {
            // Prevent iOS Safari from pausing timers when scrolling
            if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                document.addEventListener('scroll', function() {
                    // Keep timers active during scroll
                }, { passive: true });
            }
            
            // Improve touch responsiveness
            document.addEventListener('touchstart', function() {}, { passive: true });
            
            // Handle orientation change
            window.addEventListener('orientationchange', function() {
                // Small delay to let the browser finish the orientation change
                // Don't auto-scroll on orientation change
            });
        }

        /**
         * FALLBACK: Minimal, safe client markdown renderer.
         * Purpose: readability if /api/markdown/render is unavailable.
         * Scope: paragraphs, UL/OL, inline code, fenced code (escaped). No advanced GFM.
         * Keep behavior broadly aligned with server MarkdownService preprocessing, but do not
         * attempt full parity. Always prioritize server-side rendering for correctness.
         */
        function clientMarkdownFallback(text) {
            if (!text) return '';
            if (window.MU) { 
                text = MU.normalizeOpeningFences(text); 
                text = MU.promoteLikelyJavaBlocks(text);
            }
            // Extract fenced code blocks and replace with placeholders
            const codeBlocks = [];
            let s = text.replace(/```([\w-]+)?\n?([\s\S]*?)\n?```/g, (m, lang, code) => {
                const idx = codeBlocks.push({ lang: (lang||'').trim(), code: code.trim() }) - 1;
                return `\n\n[[CODE_BLOCK_${idx}]]\n\n`;
            });

            // Normalize lists safely now that code is protected
            if (window.MU) {
                try { s = MU.normalizeInlineOrderedLists(s); s = MU.hoistMarkerOnlyLines(s); } catch {}
            }

            // Normalize inline list markers frequently produced by models
            s = s.replace(/(:)\s*[-*+•→▸◆□▪]\s+(?=\S)/g, '$1\n\n- ');
            s = s.replace(/([.!?])\s+(\d+\.\s+)/g, '$1\n\n$2');
            s = s.replace(/([.!?])\s+([-*+•→▸◆□▪]\s+)/g, '$1\n\n$2');

            // Escape HTML globally
            s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // Inline code
            s = s.replace(/`([^`]+)`/g, (m, c) => `<code>${escapeHtml(c)}</code>`);

            // Minimal emphasis handling (after code is protected)
            // Normalize "** text **" -> "**text**" then render strong
            s = s.replace(/\*\*\s+([\s\S]*?)\s+\*\*/g, '**$1**');
            s = s.replace(/\*\*([^*][\s\S]*?)\*\*/g, '<strong>$1</strong>');
            // Optionally handle *italic* conservatively
            s = s.replace(/(^|[^*])\*\s*([^*][^\n]*?)\s*\*(?!\*)/g, (m, pfx, body) => `${pfx}<em>${body}</em>`);

            // Minimal headings (fallback only)
            s = s.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>')
                 .replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>')
                 .replace(/^####\s+(.+)$/gm, '<h4>$1</h4>')
                 .replace(/^###\s+(.+)$/gm, '<h3>$1</h3>')
                 .replace(/^##\s+(.+)$/gm, '<h2>$1</h2>')
                 .replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');

            const lines = s.split(/\r?\n/);
            let out = '';
            let inUl = false, inOl = false, para = '';
            const closeLists = () => { if (inUl) { out += '</ul>'; inUl = false; } if (inOl) { out += '</ol>'; inOl = false; } };
            const flushPara = () => { if (para.trim()) { out += `<p>${para.trim()}</p>`; } para = ''; };

            for (let raw of lines) {
                const line = raw.replace(/\s+$/, '');
                const codePh = line.match(/^\[\[CODE_BLOCK_(\d+)\]\]$/);
                if (codePh) {
                    flushPara(); closeLists();
                    const idx = parseInt(codePh[1], 10);
                    const blk = codeBlocks[idx] || { lang: '', code: '' };
                    const escaped = escapeHtml(blk.code);
                    const langClass = blk.lang ? ` class="language-${blk.lang}"` : '';
                    out += `<pre><code${langClass}>${escaped}</code></pre>`;
                    continue;
                }

                if (/^\s*$/.test(line)) { // blank line
                    flushPara(); closeLists();
                    continue;
                }
                if (/^[-*+•→▸◆□▪]\s+/.test(line)) {
                    flushPara();
                    if (!inUl) { closeLists(); out += '<ul>'; inUl = true; }
                    out += `<li>${line.replace(/^[-*+•→▸◆□▪]\s+/, '')}</li>`;
                    continue;
                }
                if (/^\d+\.\s+/.test(line)) {
                    flushPara();
                    if (!inOl) { closeLists(); out += '<ol>'; inOl = true; }
                    out += `<li>${line.replace(/^\d+\.\s+/, '')}</li>`;
                    continue;
                }
                // paragraph continuation
                para += (para ? ' ' : '') + line;
            }
            flushPara(); closeLists();

            // Reinsert fenced code blocks (already escaped)
            out = out.replace(/\[\[CODE_BLOCK_(\d+)\]\]/g, (m, i) => {
                const idx = parseInt(i, 10);
                const blk = codeBlocks[idx] || { lang: '', code: '' };
                const escaped = escapeHtml(blk.code);
                const langClass = blk.lang ? ` class=\"language-${blk.lang}\"` : '';
                return `<pre><code${langClass}>${escaped}</code></pre>`;
            });
            return out;
        }
        
        async function loadCitations(query, container) {
            try {
                const response = await fetch('/api/chat/citations?q=' + encodeURIComponent(query));
                if (!response.ok) return;
                const citations = await response.json();
                if (!citations || citations.length === 0) return;
                
                let citationsRow;
                
                // Use shared citation rendering function with fallback
                if (typeof MU !== 'undefined' && MU.createCitationsRow) {
                    citationsRow = MU.createCitationsRow(citations, 5);
                } else {
                    // Fallback: create simple citations without icons (regression-safe)
                    console.warn('MU.createCitationsRow not available, using fallback');
                    citationsRow = document.createElement('div');
                    citationsRow.className = 'citations-row';
                    citations.slice(0, 5).forEach((citation, index) => {
                        const pill = document.createElement(citation.url ? 'a' : 'div');
                        pill.className = 'citation-pill';
                        if (citation.url) {
                            pill.href = citation.url;
                            pill.target = '_blank';
                            pill.rel = 'noopener noreferrer';
                        }
                        const fallbackLabel = (citation.title || 'Source').replace(/::/g, '|');
                        pill.textContent = `${index + 1}. ${fallbackLabel}`;
                        citationsRow.appendChild(pill);
                    });
                }
                
                // Always append citations at the end (export button is now positioned absolutely)
                container.appendChild(citationsRow);
            } catch (error) { console.error('Error loading citations:', error); }
        }
        
        async function loadEnrichment(query, container) {
            console.debug('[DEBUG] loadEnrichment called for query:', query);
            // Robust enrichment loader with deduplication: check if enrichments already exist from inline markdown
            try {
                const response = await fetch('/api/chat/enrich?q=' + encodeURIComponent(query));
                if (!response.ok) return;
                const enrichment = await response.json();
                console.debug('[DEBUG] Enrichment API response:', enrichment);

                const normalize = (arr) => (Array.isArray(arr) ? arr : [])
                    .map(v => (typeof v === 'string' ? v.trim() : ''))
                    .filter(v => v.length > 0);

                const hints = normalize(enrichment.hints);
                const background = normalize(enrichment.background);
                const reminders = normalize(enrichment.reminders);

                // CRITICAL: Check for existing enrichments to prevent duplicates
                const existingTypes = new Set();
                container.querySelectorAll('[data-enrichment-type]').forEach(el => {
                    existingTypes.add(el.getAttribute('data-enrichment-type'));
                });

                let appended = false;
                // Only append if this type doesn't already exist (from inline markdown)
                if (hints.length > 0 && !existingTypes.has('hint')) { 
                    container.appendChild(MU.createEnrichmentBlock('hint', 'Helpful Hints', hints)); 
                    appended = true; 
                }
                if (background.length > 0 && !existingTypes.has('background')) { 
                    container.appendChild(MU.createEnrichmentBlock('background', 'Background Context', background)); 
                    appended = true; 
                }
                if (reminders.length > 0 && !existingTypes.has('reminder')) { 
                    container.appendChild(MU.createEnrichmentBlock('reminder', 'Important Reminders', reminders)); 
                    appended = true; 
                }

                console.debug('[DEBUG] Enrichment cards appended:', appended, 'Existing types:', Array.from(existingTypes));
                // If nothing valid, do not create any placeholders
                if (!appended) return;
            } catch (error) {
                // Silently ignore to avoid UI artifacts
                console.debug('Enrichment load skipped:', error);
            }
        }
        
        // knowledge-card is deprecated; unified enrichment blocks are used instead.
        
        function copyMessage(text, button) { navigator.clipboard.writeText(text).then(() => { button.classList.add('copied'); const originalHTML = button.innerHTML; button.innerHTML = `<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg>`; setTimeout(() => { button.classList.remove('copied'); button.innerHTML = originalHTML; }, 2000); }).catch(() => { showToast('Failed to copy', 'error'); }); }

        function attachCodeCopyButtons(container) {
            try {
                const blocks = container.querySelectorAll('pre');
                blocks.forEach(pre => {
                    if (pre.querySelector('.code-copy-btn')) return;
                    const btn = document.createElement('button');
                    btn.className = 'code-copy-btn';
                    btn.setAttribute('aria-label', 'Copy code');
                    btn.title = 'Copy code';
                    btn.innerHTML = `<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                        <rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect>\n                        <path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path>\n                    </svg>`;
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const codeEl = pre.querySelector('code');
                        const text = codeEl ? codeEl.innerText : pre.innerText;
                        copyMessage(text, btn);
                    });
                    pre.appendChild(btn);
                });
            } catch (err) { console.warn('Failed to attach code copy buttons', err); }
        }
        
        
        // New scroll management functions
        function scrollToBottom() {
            const chatEl = document.getElementById('chat');
            chatEl.scrollTo({
                top: chatEl.scrollHeight,
                behavior: 'smooth'
            });
            hideNewMessageIndicator();
        }
        
        function showNewMessageIndicator() {
            const chatEl = document.getElementById('chat');
            const indicator = document.querySelector('.scroll-indicator');
            if (indicator && chatEl) {
                // Show if there's content below the current viewport
                const hasContentBelow = chatEl.scrollHeight > (chatEl.scrollTop + chatEl.clientHeight + 50);
                indicator.style.display = hasContentBelow ? 'flex' : 'none';
            }
        }
        
        function hideNewMessageIndicator() {
            const indicator = document.querySelector('.scroll-indicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }
        
        // Monitor scroll position and check for content below
        function checkScrollIndicator() {
            const chatEl = document.getElementById('chat');
            const indicator = document.querySelector('.scroll-indicator');
            if (chatEl && indicator) {
                const hasContentBelow = chatEl.scrollHeight > (chatEl.scrollTop + chatEl.clientHeight + 50);
                indicator.style.display = hasContentBelow ? 'flex' : 'none';
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const chatEl = document.getElementById('chat');
            if (chatEl) {
                // Check on scroll
                chatEl.addEventListener('scroll', checkScrollIndicator);
                
                // Check on resize
                window.addEventListener('resize', checkScrollIndicator);
                
                // Check when content changes (mutations)
                const observer = new MutationObserver(checkScrollIndicator);
                observer.observe(chatEl, { childList: true, subtree: true });
                
                // Initial check
                setTimeout(checkScrollIndicator, 100);
            }
            // Show dev diagnostics on localhost
            showDevDiagnosticsIfLocal();
            
            const input = document.getElementById('q');
            // Responsive placeholder swap
            function applyResponsivePlaceholder(){
                if (!input) return;
                const w = window.innerWidth || document.documentElement.clientWidth;
                const longPh = input.getAttribute('data-placeholder-long') || input.placeholder;
                const shortPh = input.getAttribute('data-placeholder-short') || longPh;
                input.placeholder = (w <= 420) ? shortPh : longPh;
            }
            applyResponsivePlaceholder();
            window.addEventListener('resize', applyResponsivePlaceholder);
            input.focus();
            document.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') { e.preventDefault(); input.focus(); input.select(); }
                if (e.key === 'Escape' && document.activeElement === input) { input.value = ''; }
            });
        });
        
        async function copyChat() {
            try {
                // Collect all the clean markdown content from the chat
                const chatEl = document.getElementById('chat');
                const bubbles = chatEl.querySelectorAll('.bubble');
                let markdownContent = '';
                
                bubbles.forEach((bubble, index) => {
                    const isUser = bubble.classList.contains('user');
                    const messageText = bubble.textContent.trim();
                    
                    if (isUser) {
                        markdownContent += `**User:** ${messageText}\n\n`;
                    } else {
                        // Get the clean content, excluding copy buttons and other UI elements
                        const contentWrapper = bubble.querySelector('.streaming-text, .formatted-content');
                        const cleanContent = contentWrapper ? contentWrapper.textContent.trim() : messageText;
                        markdownContent += `**Assistant:** ${cleanContent}\n\n`;
                    }
                });
                
                if (!markdownContent.trim()) {
                    showToast('No messages to copy', 'error');
                    return;
                }
                
                await navigator.clipboard.writeText(markdownContent.trim());
                const btn = document.querySelector('.export-chat-btn');
                if (btn) { 
                    btn.style.background = 'var(--accent-success)'; 
                    btn.style.color = 'white'; 
                    setTimeout(() => { 
                        btn.style.background = ''; 
                        btn.style.color = ''; 
                    }, 2000); 
                } 
                showToast('All messages copied to clipboard!'); 
            } catch (error) { 
                console.error('Copy error:', error);
                showToast('Failed to copy messages', 'error'); 
            }
        }
        
        function cleanupEmptyElements(container) {
            // Remove any divs that are empty or only contain whitespace
            const allDivs = container.querySelectorAll('div');
            allDivs.forEach(div => {
                // Skip special elements
                if (div.classList.contains('loading-dots') || 
                    div.classList.contains('typing-cursor') ||
                    div.classList.contains('bubble') ||
                    div.classList.contains('streaming-text')) {
                    return;
                }
                
                // Remove if empty or only whitespace
                const text = div.textContent || '';
                if (text.trim() === '' && div.children.length === 0) {
                    div.remove();
                }
                
                // Remove knowledge cards without content
                if (div.classList.contains('knowledge-card')) {
                    const content = div.querySelector('.knowledge-card-content');
                    if (!content || !content.textContent || content.textContent.trim() === '') {
                        div.remove();
                    }
                }
                
                // Remove empty enrichment blocks
                if (div.classList.contains('inline-enrichment')) {
                    const enrichText = div.querySelector('.enrichment-text');
                    if (!enrichText || !enrichText.textContent || enrichText.textContent.trim() === '') {
                        div.remove();
                    }
                }
                
                // Remove empty citation rows
                if (div.classList.contains('citations-row') && div.children.length === 0) {
                    div.remove();
                }
            });
        }
        
        function showToast(message, type = 'success') { const toast = document.createElement('div'); toast.style.cssText = `position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; background: ${type === 'error' ? 'var(--accent-error)' : 'var(--accent-success)'}; color: white; border-radius: var(--radius-lg); box-shadow: var(--shadow-xl); z-index: 1000; animation: fadeIn 0.3s ease;`; toast.textContent = message; document.body.appendChild(toast); setTimeout(() => { toast.style.animation = 'fadeIn 0.3s ease reverse'; setTimeout(() => toast.remove(), 300); }, 3000); }
        
        document.addEventListener('DOMContentLoaded', () => {
            // Each page load gets a unique session ID, no need to clear
            
            // Signal parent that DOM is ready (prevents skeleton overlay)
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'dom-ready' }, '*');
            }
            
            // Initialize mobile optimizations
            initMobileOptimizations();
            // Ensure dev diag visibility
            showDevDiagnosticsIfLocal();
            
            const input = document.getElementById('q');
            // Responsive placeholder swap
            function applyResponsivePlaceholder(){
                if (!input) return;
                const w = window.innerWidth || document.documentElement.clientWidth;
                const longPh = input.getAttribute('data-placeholder-long') || input.placeholder;
                const shortPh = input.getAttribute('data-placeholder-short') || longPh;
                input.placeholder = (w <= 420) ? shortPh : longPh;
            }
            applyResponsivePlaceholder();
            window.addEventListener('resize', applyResponsivePlaceholder);
            input.focus();
            document.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') { e.preventDefault(); input.focus(); input.select(); }
                if (e.key === 'Escape' && document.activeElement === input) { input.value = ''; }
            });
        });

        async function renderRagDiagnostics(query) {
            if (!isLocalhost) return;
            try {
                const res = await fetch('/api/chat/diagnostics/retrieval?q=' + encodeURIComponent(query));
                const el = document.getElementById('ragContext');
                if (!el) return;
                if (!res.ok) { el.textContent = 'Diagnostics unavailable.'; return; }
                const data = await res.json();
                if (!data || !Array.isArray(data.docs) || data.docs.length === 0) { el.textContent = 'No documents retrieved yet.'; return; }
                el.innerHTML = '';
                data.docs.forEach((d, idx) => {
                    const wrap = document.createElement('div');
                    wrap.className = 'rag-doc';
                    const head = document.createElement('div');
                    head.className = 'rag-doc-head';
                    const num = document.createElement('span'); num.className = 'rag-num'; num.textContent = String(idx + 1);
                    const link = document.createElement(d.url ? 'a' : 'div');
                    if (d.url) { link.href = d.url; link.target = '_blank'; link.rel = 'noopener noreferrer'; }
                    link.className = 'citation-pill';
                    const label = document.createElement('span'); label.className = 'citation-label'; label.textContent = (d.title || d.url || 'Source');
                    link.appendChild(label);
                    head.appendChild(num); head.appendChild(link);
                    const pre = document.createElement('pre');
                    const code = document.createElement('code'); code.textContent = d.snippet || '';
                    pre.appendChild(code);
                    wrap.appendChild(head); wrap.appendChild(pre);
                    el.appendChild(wrap);
                });
                if (window.Prism) Prism.highlightAllUnder(el);
            } catch (_) {}
        }
    </script>
</body>
</html>
