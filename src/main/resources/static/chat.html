<!doctype html>
<!-- htmlhint attr-lowercase:false -->
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
    <title>Java Chat - Beautiful AI-Powered Java Learning</title>
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="icon" type="image/png" href="/favicon-196x196.png" sizes="196x196" />
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16" />
    <link rel="icon" type="image/png" href="/favicon-128.png" sizes="128x128" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="application-name" content="Java Chat"/>
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="msapplication-TileImage" content="/mstile-144x144.png" />
    <meta name="msapplication-square70x70logo" content="/mstile-70x70.png" />
    <meta name="msapplication-square150x150logo" content="/mstile-150x150.png" />
    <meta name="msapplication-wide310x150logo" content="/mstile-310x150.png" />
    <meta name="msapplication-square310x310logo" content="/mstile-310x310.png" />
    
    <!-- Mobile-specific meta tags -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="format-detection" content="telephone=no" />
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="/css/app.css?v=mobile-responsive" rel="stylesheet" />
    
</head>
<body>
    <div class="container">
        <div id="chat" role="log" aria-live="polite" aria-label="Chat messages"></div>
        
        <button class="export-chat-btn" onclick="copyChat()" aria-label="Copy entire chat" title="Copy entire chat">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2 2v1"></path>
            </svg>
        </button>
        
        
        <div class="input-area">
            <div class="input-row">
                <div class="input-wrapper">
                    <input 
                        id="q" 
                        class="input" 
                        placeholder="Ask about Java - try 'What are records?' or 'Explain pattern matching'"
                        aria-label="Enter your Java question"
                        autocomplete="off"
                        onkeypress="if(event.key==='Enter') ask()"
                    />
                    <button class="btn" onclick="ask()" id="askBtn" aria-label="Send question">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Theme Toggle Placeholder (kept for parity) -->
    <button class="theme-toggle" style="display:none" aria-hidden="true"></button>
    
    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="/js/markdown-utils.js"></script>
    
    <script>
        // Generate unique session ID for this page load
        const sessionId = 'chat-' + Date.now() + '-' + Math.random().toString(36).substring(2, 15);
        console.log('Session ID:', sessionId);
        
        // Enhanced streaming with character-by-character animation
        class StreamingText {
            constructor(element, text, speed = 30) { this.element = element; this.text = text; this.speed = speed; this.index = 0; }
            async stream() { const cursor = document.createElement('span'); cursor.className = 'typing-cursor'; this.element.appendChild(cursor); for (let i = 0; i < this.text.length; i++) { const char = this.text[i]; const textNode = document.createTextNode(char); this.element.insertBefore(textNode, cursor); await this.delay(1000 / this.speed); } cursor.remove(); }
            delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        }
        
        async function ask() {
            const input = document.getElementById('q');
            const q = input.value.trim();
            if (!q) return;
            
            const chatEl = document.getElementById('chat');
            const askBtn = document.getElementById('askBtn');
            
            // User bubble
            const userBubble = document.createElement('div');
            userBubble.className = 'bubble user';
            userBubble.textContent = q;
            const userCopyBtn = document.createElement('button');
            userCopyBtn.className = 'message-copy-btn';
            userCopyBtn.setAttribute('aria-label', 'Copy message');
            userCopyBtn.title = 'Copy message';
            userCopyBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>`;
            userCopyBtn.onclick = () => copyMessage(q, userCopyBtn);
            userBubble.appendChild(userCopyBtn);
            chatEl.appendChild(userBubble);
            
            
            input.value = '';
            askBtn.disabled = true;
            
            // Assistant bubble
            const assistantBubble = document.createElement('div');
            assistantBubble.className = 'bubble assistant';
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading-dots';
            loadingDiv.innerHTML = `
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
            `;
            assistantBubble.appendChild(loadingDiv);
            chatEl.appendChild(assistantBubble);
            chatEl.scrollTop = chatEl.scrollHeight;
            
            try {
                const response = await fetch('/api/chat/stream', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ sessionId: sessionId, latest: q }) });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                // Keep loading animation until first content chunk arrives
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'streaming-text';
                const cursor = document.createElement('span'); cursor.className = 'typing-cursor';
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullText = '';
                let buffer = '';
                // Accumulate per SSE event (all data: lines until blank line)
                let eventBuf = '';
                let hasEventData = false;
                // Debounced rendering: reduce /api/markdown/render churn and jitter
                let renderTimer = null; let lastRendered = '';
                let firstChunk = false;
                
                const flushRender = async () => { 
                    try { 
                        if (fullText === lastRendered) return; 
                        
                        // Remove loading animation on first content chunk
                        if (!firstChunk && fullText.trim()) {
                            firstChunk = true;
                            loadingDiv.remove();
                            assistantBubble.appendChild(contentWrapper);
                            contentWrapper.appendChild(cursor);
                        }
                        
                        const formatted = await formatText(fullText); 
                        contentWrapper.innerHTML = formatted; 
                        
                        // Safe function calls with error handling
                        try {
                            upgradeCodeBlocks(contentWrapper);
                        } catch (err) {
                            console.debug('upgradeCodeBlocks error (non-critical):', err);
                        }
                        
                        try {
                            attachCodeCopyButtons(contentWrapper);
                        } catch (err) {
                            console.debug('attachCodeCopyButtons error (non-critical):', err);
                        }
                        
                        // Re-add cursor after content updates (only if content wrapper is in DOM)
                        if (firstChunk) {
                            contentWrapper.appendChild(cursor);
                        }
                        
                        try { (window.MU?MU.safeHighlightUnder:Prism.highlightAllUnder)(contentWrapper); } catch (err) { console.debug('highlight error (non-critical):', err); }
                        
                        lastRendered = fullText; 
                        chatEl.scrollTop = chatEl.scrollHeight; 
                    } catch(err){
                        console.error('flushRender error:', err);
                    } 
                };
                const scheduleRender = (immediate=false) => { if (immediate) { if (renderTimer) { clearTimeout(renderTimer); renderTimer=null; } flushRender(); } else { if (renderTimer) clearTimeout(renderTimer); renderTimer = setTimeout(flushRender, 120); } };
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        // Commit any in-flight SSE event at stream end
                        if (hasEventData) {
                            fullText += eventBuf;
                            eventBuf = '';
                            hasEventData = false;
                        }
                        break;
                    }
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;
                    const lines = buffer.split('\n');
                    buffer = lines[lines.length - 1];
                    for (let i = 0; i < lines.length - 1; i++) {
                        let line = lines[i];
                        if (line.endsWith('\r')) line = line.slice(0, -1);
                        // Skip SSE comments (keepalive etc.)
                        if (line.startsWith(':')) { continue; }
                        if (line.startsWith('data:')) {
                            const data = line.slice(5);
                            // Accumulate within the current SSE event; join multiple data lines with a newline
                            if (hasEventData) { eventBuf += '\n'; }
                            eventBuf += data;
                            hasEventData = true;
                        } else if (line.trim() === '') {
                            // Blank line marks the end of an SSE event; commit accumulated data
                            if (hasEventData) {
                                fullText += eventBuf;
                                eventBuf = '';
                                hasEventData = false;
                            }
                        }
                        // Client-side DIAG: log first few frames safely
                        if (i < 4 && line) {
                            try { console.debug('[DIAG] SSE line', line.slice(0, 160)); } catch(_) {}
                        }
                    }
                    // Safety: strip any leaked SSE tokens that made it into payload text
                    if (fullText.indexOf('data:') !== -1) {
                        // Remove only line-anchored SSE prefixes; preserve legitimate words (e.g., "metadata:")
                        fullText = fullText.replace(/(^|\n)\s*data:\s*/g, '$1');
                        // Also remove mid-word injections caused by token joins (e.g., "worddata:")
                        fullText = fullText.replace(/([A-Za-z0-9])data:\s*/g, '$1');
                    }
                    // Decide whether to flush immediately based on sentence/paragraph/code boundaries
                    const immediate = window.MU ? MU.shouldImmediateFlush(fullText) : (/[.!?][\"')]*\s$/.test(fullText.slice(-4)) || /\n\n/.test(fullText.slice(-2)) || fullText.endsWith('```\n'));
                    scheduleRender(immediate);
                    if (firstChunk) {
                        try { window.parent.postMessage({ type: 'content-started' }, '*'); } catch(_){}
                    }
                }
                // Final flush
                await flushRender();
                cursor.remove();
                const assistantCopyBtn = document.createElement('button');
                assistantCopyBtn.className = 'message-copy-btn';
                assistantCopyBtn.setAttribute('aria-label', 'Copy assistant response');
                assistantCopyBtn.title = 'Copy assistant response';
                assistantCopyBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>`;
                assistantCopyBtn.onclick = () => copyMessage(fullText, assistantCopyBtn);
                assistantBubble.appendChild(assistantCopyBtn);
                Prism.highlightAllUnder(assistantBubble);
                attachCodeCopyButtons(assistantBubble);
                await loadCitations(q, assistantBubble);
                await loadEnrichment(q, assistantBubble);
                
                // CRITICAL: Clean up any empty elements that might create visual artifacts
                cleanupEmptyElements(chatEl);
            } catch (error) {
                console.error('Streaming error:', error);
                assistantBubble.innerHTML = `<div style="color: var(--accent-error);">⚠️ Error: Failed to get response. Please try again.</div>`;
            } finally { askBtn.disabled = false; input.focus(); }
        }
        
        /**
         * ENHANCED: AST-based markdown rendering with structured data support.
         * Uses the new UnifiedMarkdownService for AGENTS.md compliant processing.
         * Falls back to legacy processing if needed for backward compatibility.
         * 
         * @param {string} text - The markdown text to process
         * @param {boolean} useStructured - Whether to use the new structured endpoint
         * @param {boolean} useServerMarkdown - Whether to use server-side processing
         * @returns {Promise<string>} - Processed HTML content
         */
        async function formatText(text, useStructured = true, useServerMarkdown = true) {
            // NOTE: We removed the HTML detection check because streaming responses from GPT-5
            // come as raw markdown text and need processing. The MarkdownStreamProcessor
            // is only used for special cases, not the main streaming path.
            
            if (useServerMarkdown) {
                // Try the new structured endpoint first for better processing
                if (useStructured) {
                    try {
                        const response = await fetch('/api/markdown/render/structured', { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify({ content: text }) 
                        });
                        if (response.ok) { 
                            const data = await response.json();
                            console.debug('AST-based processing:', {
                                citations: data.citations?.length || 0,
                                enrichments: data.enrichments?.length || 0,
                                processingTime: data.processingTimeMs,
                                isClean: data.isClean
                            });
                            // Server already renders enrichment cards; apply client-side link pills and styling only
                            return applyCustomEnrichments(data.html); 
                        }
                        console.warn('Structured markdown failed, falling back to legacy:', response.status);
                    } catch (error) { 
                        console.warn('Structured markdown error, falling back to legacy:', error); 
                    }
                }
                
                // Fallback to legacy endpoint (still uses new processStructured internally)
                try {
                    const response = await fetch('/api/markdown/render', { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ content: text }) 
                    });
                    if (response.ok) { 
                        const data = await response.json(); 
                        return applyCustomEnrichments(data.html); 
                    }
                    console.error('Server markdown failed with status:', response.status);
                } catch (error) { 
                    console.error('Server markdown error:', error); 
                }
            }
            // Safety net: preserve enrichments, do minimal client markdown, then restore and enrich
            const preserved = preserveEnrichments(text);
            let html = clientMarkdownFallback(preserved);
            if (window.MU && MU.hoistMarkerOnlyLines) html = MU.hoistMarkerOnlyLines(html);
            const restored = restoreEnrichments(html);
            return applyCustomEnrichments(restored);
        }
        
        function applyCustomEnrichments(text) {
            if (window.MU && MU.applyInlineEnrichments) {
                return MU.applyInlineEnrichments(text);
            }
            return text;
        }
        
        function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }

        /**
         * FALLBACK: Preserve custom enrichment blocks while client-side parsing.
         * Mirrors server placeholders in MarkdownService.preserveEnrichments().
         * Focus fixes on server first; keep placeholder format in sync with server.
         */
        function preserveEnrichments(text) {
            return text.replace(/\{\{(hint|reminder|background|example|warning):([\s\S]*?)\}\}/g, (m, t, c) => `ZZENRICHZ${t}ZSTARTZZZ${c}ZZENRICHZ${t}ZENDZZZ`);
        }
        /**
         * FALLBACK: Restore enrichment placeholders back to {{type:content}} after client parse.
         * Mirrors MarkdownService.restoreEnrichments(). Keep in sync with server format.
         */
        function restoreEnrichments(html) {
            return html.replace(/ZZENRICHZ(\w+)ZSTARTZZZ([\s\S]*?)ZZENRICHZ\1ZENDZZZ/g, (m, t, c) => `{{${t}:${c}}}`);
        }

        /**
         * Safe code block upgrade function for chat.html
         * CONSERVATIVE: Only ensures proper language classes for syntax highlighting
         * Does NOT modify structure to avoid regressions
         */
        function upgradeCodeBlocks(container) {
            try {
                // Safety check: if container is invalid, return silently
                if (!container || typeof container.querySelectorAll !== 'function') {
                    console.debug('upgradeCodeBlocks: Invalid container, skipping');
                    return;
                }
                
                // CRITICAL: We do NOT convert inline code to blocks
                // The server-side markdown parser already handles this distinction
                // Converting multi-line inline code to blocks causes the exact issue we're fixing
                
                // Only ensure code blocks have proper language classes for Prism.js
                const codeBlocks = container.querySelectorAll('pre > code');
                codeBlocks.forEach(code => {
                    // If no language class, try to detect from content
                    if (!code.className || !code.className.includes('language-')) {
                        const text = code.textContent || '';
                        // Check for Java code patterns
                        if (text.includes('public class') || text.includes('import java') || 
                            text.includes('public static void') || text.includes('HashMap') ||
                            text.includes('String') || text.includes('System.out') ||
                            text.includes('Integer') || text.includes('ArrayList')) {
                            code.className = 'language-java';
                        }
                    }
                });
                
                // CRITICAL: We do NOT wrap pre blocks in enrichment containers
                // This causes the rendering issue where code appears inline
                // The server decides when to wrap code in special containers
                
                console.debug(`upgradeCodeBlocks: Processed ${codeBlocks.length} code blocks safely`);
                
            } catch (err) {
                // Fail silently to prevent breaking the UI
                console.debug('upgradeCodeBlocks: Non-critical error', err);
            }
        }
        
        // Mobile-specific optimizations
        function initMobileOptimizations() {
            // Prevent iOS Safari from pausing timers when scrolling
            if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                document.addEventListener('scroll', function() {
                    // Keep timers active during scroll
                }, { passive: true });
            }
            
            // Improve touch responsiveness
            document.addEventListener('touchstart', function() {}, { passive: true });
            
            // Handle orientation change
            window.addEventListener('orientationchange', function() {
                // Small delay to let the browser finish the orientation change
                setTimeout(() => {
                    // Scroll to maintain position
                    const chatEl = document.getElementById('chat');
                    if (chatEl) {
                        chatEl.scrollTop = chatEl.scrollHeight;
                    }
                }, 100);
            });
        }

        /**
         * FALLBACK: Minimal, safe client markdown renderer.
         * Purpose: readability if /api/markdown/render is unavailable.
         * Scope: paragraphs, UL/OL, inline code, fenced code (escaped). No advanced GFM.
         * Keep behavior broadly aligned with server MarkdownService preprocessing, but do not
         * attempt full parity. Always prioritize server-side rendering for correctness.
         */
        function clientMarkdownFallback(text) {
            if (!text) return '';
            if (window.MU) { 
                text = MU.normalizeOpeningFences(text); 
                text = MU.promoteLikelyJavaBlocks(text);
            }
            // Extract fenced code blocks and replace with placeholders
            const codeBlocks = [];
            let s = text.replace(/```([\w-]+)?\n?([\s\S]*?)\n?```/g, (m, lang, code) => {
                const idx = codeBlocks.push({ lang: (lang||'').trim(), code: code.trim() }) - 1;
                return `\n\n[[CODE_BLOCK_${idx}]]\n\n`;
            });

            // Normalize lists safely now that code is protected
            if (window.MU) {
                try { s = MU.normalizeInlineOrderedLists(s); s = MU.hoistMarkerOnlyLines(s); } catch {}
            }

            // Normalize inline list markers frequently produced by models
            s = s.replace(/(:)\s*[-*+•→▸◆□▪]\s+(?=\S)/g, '$1\n\n- ');
            s = s.replace(/([.!?])\s+(\d+\.\s+)/g, '$1\n\n$2');
            s = s.replace(/([.!?])\s+([-*+•→▸◆□▪]\s+)/g, '$1\n\n$2');

            // Escape HTML globally
            s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // Inline code
            s = s.replace(/`([^`]+)`/g, (m, c) => `<code>${escapeHtml(c)}</code>`);

            // Minimal emphasis handling (after code is protected)
            // Normalize "** text **" -> "**text**" then render strong
            s = s.replace(/\*\*\s+([\s\S]*?)\s+\*\*/g, '**$1**');
            s = s.replace(/\*\*([^*][\s\S]*?)\*\*/g, '<strong>$1</strong>');
            // Optionally handle *italic* conservatively
            s = s.replace(/(^|[^*])\*\s*([^*][^\n]*?)\s*\*(?!\*)/g, (m, pfx, body) => `${pfx}<em>${body}</em>`);

            // Minimal headings (fallback only)
            s = s.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>')
                 .replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>')
                 .replace(/^####\s+(.+)$/gm, '<h4>$1</h4>')
                 .replace(/^###\s+(.+)$/gm, '<h3>$1</h3>')
                 .replace(/^##\s+(.+)$/gm, '<h2>$1</h2>')
                 .replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');

            const lines = s.split(/\r?\n/);
            let out = '';
            let inUl = false, inOl = false, para = '';
            const closeLists = () => { if (inUl) { out += '</ul>'; inUl = false; } if (inOl) { out += '</ol>'; inOl = false; } };
            const flushPara = () => { if (para.trim()) { out += `<p>${para.trim()}</p>`; } para = ''; };

            for (let raw of lines) {
                const line = raw.replace(/\s+$/, '');
                const codePh = line.match(/^\[\[CODE_BLOCK_(\d+)\]\]$/);
                if (codePh) {
                    flushPara(); closeLists();
                    const idx = parseInt(codePh[1], 10);
                    const blk = codeBlocks[idx] || { lang: '', code: '' };
                    const escaped = escapeHtml(blk.code);
                    const langClass = blk.lang ? ` class="language-${blk.lang}"` : '';
                    out += `<pre><code${langClass}>${escaped}</code></pre>`;
                    continue;
                }

                if (/^\s*$/.test(line)) { // blank line
                    flushPara(); closeLists();
                    continue;
                }
                if (/^[-*+•→▸◆□▪]\s+/.test(line)) {
                    flushPara();
                    if (!inUl) { closeLists(); out += '<ul>'; inUl = true; }
                    out += `<li>${line.replace(/^[-*+•→▸◆□▪]\s+/, '')}</li>`;
                    continue;
                }
                if (/^\d+\.\s+/.test(line)) {
                    flushPara();
                    if (!inOl) { closeLists(); out += '<ol>'; inOl = true; }
                    out += `<li>${line.replace(/^\d+\.\s+/, '')}</li>`;
                    continue;
                }
                // paragraph continuation
                para += (para ? ' ' : '') + line;
            }
            flushPara(); closeLists();

            // Reinsert fenced code blocks (already escaped)
            out = out.replace(/\[\[CODE_BLOCK_(\d+)\]\]/g, (m, i) => {
                const idx = parseInt(i, 10);
                const blk = codeBlocks[idx] || { lang: '', code: '' };
                const escaped = escapeHtml(blk.code);
                const langClass = blk.lang ? ` class=\"language-${blk.lang}\"` : '';
                return `<pre><code${langClass}>${escaped}</code></pre>`;
            });
            return out;
        }
        
        async function loadCitations(query, container) {
            try {
                const response = await fetch('/api/chat/citations?q=' + encodeURIComponent(query));
                if (!response.ok) return;
                const citations = await response.json();
                if (!citations || citations.length === 0) return;
                
                let citationsRow;
                
                // Use shared citation rendering function with fallback
                if (typeof MU !== 'undefined' && MU.createCitationsRow) {
                    citationsRow = MU.createCitationsRow(citations, 5);
                } else {
                    // Fallback: create simple citations without icons (regression-safe)
                    console.warn('MU.createCitationsRow not available, using fallback');
                    citationsRow = document.createElement('div');
                    citationsRow.className = 'citations-row';
                    citations.slice(0, 5).forEach((citation, index) => {
                        const pill = document.createElement(citation.url ? 'a' : 'div');
                        pill.className = 'citation-pill';
                        if (citation.url) {
                            pill.href = citation.url;
                            pill.target = '_blank';
                            pill.rel = 'noopener noreferrer';
                        }
                        const fallbackLabel = (citation.title || 'Source').replace(/::/g, '|');
                        pill.textContent = `${index + 1}. ${fallbackLabel}`;
                        citationsRow.appendChild(pill);
                    });
                }
                
                // Always append citations at the end (export button is now positioned absolutely)
                container.appendChild(citationsRow);
            } catch (error) { console.error('Error loading citations:', error); }
        }
        
        async function loadEnrichment(query, container) {
            console.debug('[DEBUG] loadEnrichment called for query:', query);
            // Robust enrichment loader with deduplication: check if enrichments already exist from inline markdown
            try {
                const response = await fetch('/api/chat/enrich?q=' + encodeURIComponent(query));
                if (!response.ok) return;
                const enrichment = await response.json();
                console.debug('[DEBUG] Enrichment API response:', enrichment);

                const normalize = (arr) => (Array.isArray(arr) ? arr : [])
                    .map(v => (typeof v === 'string' ? v.trim() : ''))
                    .filter(v => v.length > 0);

                const hints = normalize(enrichment.hints);
                const background = normalize(enrichment.background);
                const reminders = normalize(enrichment.reminders);

                // CRITICAL: Check for existing enrichments to prevent duplicates
                const existingTypes = new Set();
                container.querySelectorAll('[data-enrichment-type]').forEach(el => {
                    existingTypes.add(el.getAttribute('data-enrichment-type'));
                });

                let appended = false;
                // Only append if this type doesn't already exist (from inline markdown)
                if (hints.length > 0 && !existingTypes.has('hint')) { 
                    container.appendChild(MU.createEnrichmentBlock('hint', 'Helpful Hints', hints)); 
                    appended = true; 
                }
                if (background.length > 0 && !existingTypes.has('background')) { 
                    container.appendChild(MU.createEnrichmentBlock('background', 'Background Context', background)); 
                    appended = true; 
                }
                if (reminders.length > 0 && !existingTypes.has('reminder')) { 
                    container.appendChild(MU.createEnrichmentBlock('reminder', 'Important Reminders', reminders)); 
                    appended = true; 
                }

                console.debug('[DEBUG] Enrichment cards appended:', appended, 'Existing types:', Array.from(existingTypes));
                // If nothing valid, do not create any placeholders
                if (!appended) return;
            } catch (error) {
                // Silently ignore to avoid UI artifacts
                console.debug('Enrichment load skipped:', error);
            }
        }
        
        // knowledge-card is deprecated; unified enrichment blocks are used instead.
        
        function copyMessage(text, button) { navigator.clipboard.writeText(text).then(() => { button.classList.add('copied'); const originalHTML = button.innerHTML; button.innerHTML = `<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg>`; setTimeout(() => { button.classList.remove('copied'); button.innerHTML = originalHTML; }, 2000); }).catch(() => { showToast('Failed to copy', 'error'); }); }

        function attachCodeCopyButtons(container) {
            try {
                const blocks = container.querySelectorAll('pre');
                blocks.forEach(pre => {
                    if (pre.querySelector('.code-copy-btn')) return;
                    const btn = document.createElement('button');
                    btn.className = 'code-copy-btn';
                    btn.setAttribute('aria-label', 'Copy code');
                    btn.title = 'Copy code';
                    btn.innerHTML = `<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                        <rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect>\n                        <path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path>\n                    </svg>`;
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const codeEl = pre.querySelector('code');
                        const text = codeEl ? codeEl.innerText : pre.innerText;
                        copyMessage(text, btn);
                    });
                    pre.appendChild(btn);
                });
            } catch (err) { console.warn('Failed to attach code copy buttons', err); }
        }
        
        
        async function copyChat() {
            try { const res = await fetch('/api/chat/export/session?sessionId=' + encodeURIComponent(sessionId)); const txt = await res.text(); await navigator.clipboard.writeText(txt); const btn = document.querySelector('.export-chat-btn'); if (btn) { btn.style.background = 'var(--accent-success)'; btn.style.color = 'white'; setTimeout(() => { btn.style.background = ''; btn.style.color = ''; }, 2000); } showToast('Chat session exported to clipboard!'); } catch (error) { showToast('Failed to export', 'error'); }
        }
        
        function cleanupEmptyElements(container) {
            // Remove any divs that are empty or only contain whitespace
            const allDivs = container.querySelectorAll('div');
            allDivs.forEach(div => {
                // Skip special elements
                if (div.classList.contains('loading-dots') || 
                    div.classList.contains('typing-cursor') ||
                    div.classList.contains('bubble') ||
                    div.classList.contains('streaming-text')) {
                    return;
                }
                
                // Remove if empty or only whitespace
                const text = div.textContent || '';
                if (text.trim() === '' && div.children.length === 0) {
                    div.remove();
                }
                
                // Remove knowledge cards without content
                if (div.classList.contains('knowledge-card')) {
                    const content = div.querySelector('.knowledge-card-content');
                    if (!content || !content.textContent || content.textContent.trim() === '') {
                        div.remove();
                    }
                }
                
                // Remove empty enrichment blocks
                if (div.classList.contains('inline-enrichment')) {
                    const enrichText = div.querySelector('.enrichment-text');
                    if (!enrichText || !enrichText.textContent || enrichText.textContent.trim() === '') {
                        div.remove();
                    }
                }
                
                // Remove empty citation rows
                if (div.classList.contains('citations-row') && div.children.length === 0) {
                    div.remove();
                }
            });
        }
        
        function showToast(message, type = 'success') { const toast = document.createElement('div'); toast.style.cssText = `position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; background: ${type === 'error' ? 'var(--accent-error)' : 'var(--accent-success)'}; color: white; border-radius: var(--radius-lg); box-shadow: var(--shadow-xl); z-index: 1000; animation: fadeIn 0.3s ease;`; toast.textContent = message; document.body.appendChild(toast); setTimeout(() => { toast.style.animation = 'fadeIn 0.3s ease reverse'; setTimeout(() => toast.remove(), 300); }, 3000); }
        
        document.addEventListener('DOMContentLoaded', () => {
            // Each page load gets a unique session ID, no need to clear
            
            // Signal parent that DOM is ready (prevents skeleton overlay)
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'dom-ready' }, '*');
            }
            
            // Initialize mobile optimizations
            initMobileOptimizations();
            
            const input = document.getElementById('q');
            input.focus();
            document.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') { e.preventDefault(); input.focus(); input.select(); }
                if (e.key === 'Escape' && document.activeElement === input) { input.value = ''; }
            });
        });
    </script>
</body>
</html>
