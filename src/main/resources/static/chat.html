<!doctype html>
<!-- htmlhint attr-lowercase:false -->
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Java Chat - Beautiful AI-Powered Java Learning</title>
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="icon" type="image/png" href="/favicon-196x196.png" sizes="196x196" />
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16" />
    <link rel="icon" type="image/png" href="/favicon-128.png" sizes="128x128" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="application-name" content="Java Chat"/>
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="msapplication-TileImage" content="/mstile-144x144.png" />
    <meta name="msapplication-square70x70logo" content="/mstile-70x70.png" />
    <meta name="msapplication-square150x150logo" content="/mstile-150x150.png" />
    <meta name="msapplication-wide310x150logo" content="/mstile-310x150.png" />
    <meta name="msapplication-square310x310logo" content="/mstile-310x310.png" />
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="/css/app.css" rel="stylesheet" />
    
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1 class="app-title">Java Chat</h1>
                <span class="pill">
                    <span class="status-indicator"></span>
                    JDK 24 Docs
                </span>
                <span class="pill">AI-Powered Learning</span>
            </div>
            <div class="header-right"></div>
        </div>
        
        <div id="chat" role="log" aria-live="polite" aria-label="Chat messages"></div>
        
        <button class="export-chat-btn" onclick="copyChat()" aria-label="Copy entire chat" title="Copy entire chat">
            <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
        </button>
        
        <div class="input-area">
            <div class="input-row">
                <div class="input-wrapper">
                    <input 
                        id="q" 
                        class="input" 
                        placeholder="Ask about Java - try 'What are records?' or 'Explain pattern matching'"
                        aria-label="Enter your Java question"
                        autocomplete="off"
                        onkeypress="if(event.key==='Enter') ask()"
                    />
                    <button class="btn" onclick="ask()" id="askBtn" aria-label="Send question">
                        <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Theme Toggle Placeholder (kept for parity) -->
    <button class="theme-toggle" style="display:none" aria-hidden="true"></button>
    
    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="/js/markdown-utils.js"></script>
    
    <script>
        // Enhanced streaming with character-by-character animation
        class StreamingText {
            constructor(element, text, speed = 30) { this.element = element; this.text = text; this.speed = speed; this.index = 0; }
            async stream() { const cursor = document.createElement('span'); cursor.className = 'typing-cursor'; this.element.appendChild(cursor); for (let i = 0; i < this.text.length; i++) { const char = this.text[i]; const textNode = document.createTextNode(char); this.element.insertBefore(textNode, cursor); await this.delay(1000 / this.speed); } cursor.remove(); }
            delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        }
        
        async function ask() {
            const input = document.getElementById('q');
            const q = input.value.trim();
            if (!q) return;
            
            const chatEl = document.getElementById('chat');
            const askBtn = document.getElementById('askBtn');
            
            // User bubble
            const userBubble = document.createElement('div');
            userBubble.className = 'bubble user';
            userBubble.textContent = q;
            const userCopyBtn = document.createElement('button');
            userCopyBtn.className = 'message-copy-btn';
            userCopyBtn.setAttribute('aria-label', 'Copy message');
            userCopyBtn.title = 'Copy message';
            userCopyBtn.innerHTML = `<svg width="16" height="16" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>`;
            userCopyBtn.onclick = () => copyMessage(q, userCopyBtn);
            userBubble.appendChild(userCopyBtn);
            chatEl.appendChild(userBubble);
            
            input.value = '';
            askBtn.disabled = true;
            
            // Assistant bubble
            const assistantBubble = document.createElement('div');
            assistantBubble.className = 'bubble assistant';
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading-dots';
            loadingDiv.innerHTML = `
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
            `;
            assistantBubble.appendChild(loadingDiv);
            chatEl.appendChild(assistantBubble);
            chatEl.scrollTop = chatEl.scrollHeight;
            
            try {
                const response = await fetch('/api/chat/stream', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ sessionId: 'web', latest: q }) });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                // Keep loading animation until first content chunk arrives
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'streaming-text';
                const cursor = document.createElement('span'); cursor.className = 'typing-cursor';
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullText = '';
                let buffer = '';
                // Debounced rendering: reduce /api/markdown/render churn and jitter
                let renderTimer = null; let lastRendered = '';
                let firstChunk = false;
                // Track if we're in a list or code block
                let inList = false;
                let inCode = false;
                const flushRender = async () => { 
                    try { 
                        if (fullText === lastRendered) return; 
                        
                        // Remove loading animation on first content chunk
                        if (!firstChunk && fullText.trim()) {
                            firstChunk = true;
                            loadingDiv.remove();
                            assistantBubble.appendChild(contentWrapper);
                            contentWrapper.appendChild(cursor);
                        }
                        
                        const formatted = await formatText(fullText); 
                        contentWrapper.innerHTML = formatted; 
                        
                        // Safe function calls with error handling
                        try {
                            upgradeCodeBlocks(contentWrapper);
                        } catch (err) {
                            console.debug('upgradeCodeBlocks error (non-critical):', err);
                        }
                        
                        try {
                            attachCodeCopyButtons(contentWrapper);
                        } catch (err) {
                            console.debug('attachCodeCopyButtons error (non-critical):', err);
                        }
                        
                        // Re-add cursor after content updates (only if content wrapper is in DOM)
                        if (firstChunk) {
                            contentWrapper.appendChild(cursor);
                        }
                        
                        try { (window.MU?MU.safeHighlightUnder:Prism.highlightAllUnder)(contentWrapper); } catch (err) { console.debug('highlight error (non-critical):', err); }
                        
                        lastRendered = fullText; 
                        chatEl.scrollTop = chatEl.scrollHeight; 
                    } catch(err){
                        console.error('flushRender error:', err);
                    } 
                };
                const scheduleRender = (immediate=false) => { if (immediate) { if (renderTimer) { clearTimeout(renderTimer); renderTimer=null; } flushRender(); } else { if (renderTimer) clearTimeout(renderTimer); renderTimer = setTimeout(flushRender, 120); } };
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;
                    const lines = buffer.split('\n');
                    buffer = lines[lines.length - 1];
                    for (let i = 0; i < lines.length - 1; i++) {
                        let line = lines[i];
                        if (line.endsWith('\r')) line = line.slice(0, -1);
                        if (line.startsWith('data:')) {
                            const data = line.slice(5);
                            
                            // STEP 1: Check for code block boundaries FIRST
                            if (data.includes('```')) {
                                const beforeFence = data.indexOf('```');
                                if (beforeFence > 0) {
                                    fullText += data.substring(0, beforeFence);
                                }
                                inCode = !inCode;
                                fullText += data.substring(beforeFence) + '\n';
                                inList = false;
                                continue;
                            }
                            
                            // STEP 2: If in code block, preserve exactly
                            if (inCode) {
                                fullText += data + '\n';
                                continue;
                            }
                            
                            // STEP 3: Check for list markers
                            const startsWithListMarker = /^\s*(?:\d+[.)]|[a-zA-Z][.)]|[-*+])\s+/.test(data);
                            
                            // Handle empty lines - they end lists
                            if (!data) {
                                if (inList) {
                                    fullText += '\n';
                                    inList = false;
                                } else {
                                    fullText += '\n';
                                }
                                continue;
                            }
                            
                            // Check for split list marker ("1." in one chunk, text in next)
                            const tail = fullText.slice(-10).trim();
                            const endsWithListMarker = /(?:\d+[.)]|[a-zA-Z][.)]|[-*+])\s*$/.test(tail);
                            if (endsWithListMarker && /^\S/.test(data)) {
                                // This is continuation of a list marker - just append with space
                                fullText += ' ' + data;
                                inList = true;
                                continue;
                            }
                            
                            // New list item starting
                            if (startsWithListMarker) {
                                if (fullText.length > 0 && !fullText.endsWith('\n')) {
                                    // Add newline before new list item
                                    fullText += inList ? '\n' : '\n\n';
                                }
                                fullText += data;
                                inList = true;
                                continue;
                            }
                            
                            // STEP 4: Are we in a list?
                            if (inList) {
                                // Continuation of current list item - just add space if needed
                                const needsSpace = fullText.length > 0 && 
                                                  !fullText.endsWith(' ') && 
                                                  !fullText.endsWith('\n') &&
                                                  !data.startsWith(' ');
                                fullText += needsSpace ? ' ' + data : data;
                                continue;
                            }
                            
                            // STEP 5: Regular paragraph (not in list, not in code)
                            if (fullText.length > 0) {
                                // Need double newline before new paragraph
                                if (!fullText.endsWith('\n\n')) {
                                    if (fullText.endsWith('\n')) {
                                        fullText += '\n';
                                    } else {
                                        fullText += '\n\n';
                                    }
                                }
                            }
                            fullText += data;
                        }
                    }
                    // Decide whether to flush immediately based on sentence/paragraph/code boundaries
                    // IMPORTANT: Only treat a code-fence boundary as complete when followed by a newline
                    // to avoid rendering half-fences like "```javaimport ..." inline.
                    const immediate = window.MU ? MU.shouldImmediateFlush(fullText) : (/[.!?][\"')]*\s$/.test(fullText.slice(-4)) || /\n\n/.test(fullText.slice(-2)) || fullText.endsWith('```\n'));
                    scheduleRender(immediate);
                    if (firstChunk) {
                        try { window.parent.postMessage({ type: 'content-started' }, '*'); } catch(_){}
                    }
                }
                // Final flush
                await flushRender();
                cursor.remove();
                const assistantCopyBtn = document.createElement('button');
                assistantCopyBtn.className = 'message-copy-btn';
                assistantCopyBtn.setAttribute('aria-label', 'Copy assistant response');
                assistantCopyBtn.title = 'Copy assistant response';
                assistantCopyBtn.innerHTML = `<svg width="16" height="16" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>`;
                assistantCopyBtn.onclick = () => copyMessage(fullText, assistantCopyBtn);
                assistantBubble.appendChild(assistantCopyBtn);
                Prism.highlightAllUnder(assistantBubble);
                attachCodeCopyButtons(assistantBubble);
                await loadCitations(q, assistantBubble);
                await loadEnrichment(q, assistantBubble);
                
                // CRITICAL: Clean up any empty elements that might create visual artifacts
                cleanupEmptyElements(chatEl);
            } catch (error) {
                console.error('Streaming error:', error);
                assistantBubble.innerHTML = `<div style="color: var(--accent-error);">⚠️ Error: Failed to get response. Please try again.</div>`;
            } finally { askBtn.disabled = false; input.focus(); }
        }
        
        /**
         * FALLBACK-AWARE: Markdown rendering with server-side support and a minimal client-side fallback.
         * Source of truth: com.williamcallahan.javachat.service.MarkdownService (server).
         * If the server endpoint /api/markdown/render fails, we use a BASIC client parser
         * solely to maintain readability (paragraphs, UL/OL, inline code, fenced code).
         * Keep this fallback aligned with server logic:
         *   - preprocessMarkdown()
         *   - applySmartParagraphBreaksImproved()
         *   - fixInlineLists()
         *   - protectCodeBlocks()
         *   - restoreEnrichments()
         *   - render()
         * IMPORTANT: Always fix/extend server behavior first. The fallback is intentionally limited.
         */
        async function formatText(text, useServerMarkdown = true) {
            if (useServerMarkdown) {
                try {
                    const response = await fetch('/api/markdown/render', { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ content: text }) 
                    });
                    if (response.ok) { 
                        const data = await response.json(); 
                        return applyCustomEnrichments(data.html); 
                    }
                    console.error('Server markdown failed with status:', response.status);
                } catch (error) { 
                    console.error('Server markdown error:', error); 
                }
            }
            // Safety net: preserve enrichments, do minimal client markdown, then restore and enrich
            const preserved = preserveEnrichments(text);
            let html = clientMarkdownFallback(preserved);
            if (window.MU && MU.hoistMarkerOnlyLines) html = MU.hoistMarkerOnlyLines(html);
            const restored = restoreEnrichments(html);
            return applyCustomEnrichments(restored);
        }
        
        function applyCustomEnrichments(text) {
            if (window.MU && MU.applyInlineEnrichments) {
                return MU.applyInlineEnrichments(text);
            }
            return text;
        }
        
        function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }

        /**
         * FALLBACK: Preserve custom enrichment blocks while client-side parsing.
         * Mirrors server placeholders in MarkdownService.preserveEnrichments().
         * Focus fixes on server first; keep placeholder format in sync with server.
         */
        function preserveEnrichments(text) {
            return text.replace(/\{\{(hint|reminder|background|example|warning):([\s\S]*?)\}\}/g, (m, t, c) => `ZZENRICHZ${t}ZSTARTZZZ${c}ZZENRICHZ${t}ZENDZZZ`);
        }
        /**
         * FALLBACK: Restore enrichment placeholders back to {{type:content}} after client parse.
         * Mirrors MarkdownService.restoreEnrichments(). Keep in sync with server format.
         */
        function restoreEnrichments(html) {
            return html.replace(/ZZENRICHZ(\w+)ZSTARTZZZ([\s\S]*?)ZZENRICHZ\1ZENDZZZ/g, (m, t, c) => `{{${t}:${c}}}`);
        }

        /**
         * Safe code block upgrade function for chat.html
         * CONSERVATIVE: Only ensures proper language classes for syntax highlighting
         * Does NOT modify structure to avoid regressions
         */
        function upgradeCodeBlocks(container) {
            try {
                // Safety check: if container is invalid, return silently
                if (!container || typeof container.querySelectorAll !== 'function') {
                    console.debug('upgradeCodeBlocks: Invalid container, skipping');
                    return;
                }
                
                // CRITICAL: We do NOT convert inline code to blocks
                // The server-side markdown parser already handles this distinction
                // Converting multi-line inline code to blocks causes the exact issue we're fixing
                
                // Only ensure code blocks have proper language classes for Prism.js
                const codeBlocks = container.querySelectorAll('pre > code');
                codeBlocks.forEach(code => {
                    // If no language class, try to detect from content
                    if (!code.className || !code.className.includes('language-')) {
                        const text = code.textContent || '';
                        // Check for Java code patterns
                        if (text.includes('public class') || text.includes('import java') || 
                            text.includes('public static void') || text.includes('HashMap') ||
                            text.includes('String') || text.includes('System.out') ||
                            text.includes('Integer') || text.includes('ArrayList')) {
                            code.className = 'language-java';
                        }
                    }
                });
                
                // CRITICAL: We do NOT wrap pre blocks in enrichment containers
                // This causes the rendering issue where code appears inline
                // The server decides when to wrap code in special containers
                
                console.debug(`upgradeCodeBlocks: Processed ${codeBlocks.length} code blocks safely`);
                
            } catch (err) {
                // Fail silently to prevent breaking the UI
                console.debug('upgradeCodeBlocks: Non-critical error', err);
            }
        }

        /**
         * FALLBACK: Minimal, safe client markdown renderer.
         * Purpose: readability if /api/markdown/render is unavailable.
         * Scope: paragraphs, UL/OL, inline code, fenced code (escaped). No advanced GFM.
         * Keep behavior broadly aligned with server MarkdownService preprocessing, but do not
         * attempt full parity. Always prioritize server-side rendering for correctness.
         */
        function clientMarkdownFallback(text) {
            if (!text) return '';
            if (window.MU) { 
                text = MU.normalizeOpeningFences(text); 
                text = MU.promoteLikelyJavaBlocks(text);
            }
            // Extract fenced code blocks and replace with placeholders
            const codeBlocks = [];
            let s = text.replace(/```([\w-]+)?\n([\s\S]*?)\n```/g, (m, lang, code) => {
                const idx = codeBlocks.push({ lang: (lang||'').trim(), code: code.trim() }) - 1;
                return `[[CODE_BLOCK_${idx}]]`;
            });

            // Normalize lists safely now that code is protected
            if (window.MU) {
                try { s = MU.normalizeInlineOrderedLists(s); s = MU.hoistMarkerOnlyLines(s); } catch {}
            }

            // Normalize inline list markers frequently produced by models
            s = s.replace(/(:)\s*-\s+(?=\S)/g, '$1\n\n- ');
            s = s.replace(/([.!?])\s+(\d+\.\s+)/g, '$1\n$2');

            // Escape HTML globally
            s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // Inline code
            s = s.replace(/`([^`]+)`/g, (m, c) => `<code>${escapeHtml(c)}</code>`);

            // Minimal emphasis handling (after code is protected)
            // Normalize "** text **" -> "**text**" then render strong
            s = s.replace(/\*\*\s+([\s\S]*?)\s+\*\*/g, '**$1**');
            s = s.replace(/\*\*([^*][\s\S]*?)\*\*/g, '<strong>$1</strong>');
            // Optionally handle *italic* conservatively
            s = s.replace(/(^|[^*])\*\s*([^*][^\n]*?)\s*\*(?!\*)/g, (m, pfx, body) => `${pfx}<em>${body}</em>`);

            // Minimal headings (fallback only)
            s = s.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>')
                 .replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>')
                 .replace(/^####\s+(.+)$/gm, '<h4>$1</h4>')
                 .replace(/^###\s+(.+)$/gm, '<h3>$1</h3>')
                 .replace(/^##\s+(.+)$/gm, '<h2>$1</h2>')
                 .replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');

            const lines = s.split(/\r?\n/);
            let out = '';
            let inUl = false, inOl = false, para = '';
            const closeLists = () => { if (inUl) { out += '</ul>'; inUl = false; } if (inOl) { out += '</ol>'; inOl = false; } };
            const flushPara = () => { if (para.trim()) { out += `<p>${para.trim()}</p>`; } para = ''; };

            for (let raw of lines) {
                const line = raw.replace(/\s+$/, '');
                const codePh = line.match(/^\[\[CODE_BLOCK_(\d+)\]\]$/);
                if (codePh) {
                    flushPara(); closeLists();
                    const idx = parseInt(codePh[1], 10);
                    const blk = codeBlocks[idx] || { lang: '', code: '' };
                    const escaped = escapeHtml(blk.code);
                    const langClass = blk.lang ? ` class="language-${blk.lang}"` : '';
                    out += `<pre><code${langClass}>${escaped}</code></pre>`;
                    continue;
                }

                if (/^\s*$/.test(line)) { // blank line
                    flushPara(); closeLists();
                    continue;
                }
                if (/^-\s+/.test(line)) {
                    flushPara();
                    if (!inUl) { closeLists(); out += '<ul>'; inUl = true; }
                    out += `<li>${line.replace(/^-\s+/, '')}</li>`;
                    continue;
                }
                if (/^\d+\.\s+/.test(line)) {
                    flushPara();
                    if (!inOl) { closeLists(); out += '<ol>'; inOl = true; }
                    out += `<li>${line.replace(/^\d+\.\s+/, '')}</li>`;
                    continue;
                }
                // paragraph continuation
                para += (para ? ' ' : '') + line;
            }
            flushPara(); closeLists();

            // Reinsert fenced code blocks (already escaped)
            out = out.replace(/\[\[CODE_BLOCK_(\d+)\]\]/g, (m, i) => {
                const idx = parseInt(i, 10);
                const blk = codeBlocks[idx] || { lang: '', code: '' };
                const escaped = escapeHtml(blk.code);
                const langClass = blk.lang ? ` class=\"language-${blk.lang}\"` : '';
                return `<pre><code${langClass}>${escaped}</code></pre>`;
            });
            return out;
        }
        
        async function loadCitations(query, container) {
            try {
                const response = await fetch('/api/chat/citations?q=' + encodeURIComponent(query));
                if (!response.ok) return;
                const citations = await response.json();
                if (!citations || citations.length === 0) return;
                
                let citationsRow;
                
                // Use shared citation rendering function with fallback
                if (typeof MU !== 'undefined' && MU.createCitationsRow) {
                    citationsRow = MU.createCitationsRow(citations, 5);
                } else {
                    // Fallback: create simple citations without icons (regression-safe)
                    console.warn('MU.createCitationsRow not available, using fallback');
                    citationsRow = document.createElement('div');
                    citationsRow.className = 'citations-row';
                    citations.slice(0, 5).forEach((citation, index) => {
                        const pill = document.createElement(citation.url ? 'a' : 'div');
                        pill.className = 'citation-pill';
                        if (citation.url) {
                            pill.href = citation.url;
                            pill.target = '_blank';
                            pill.rel = 'noopener noreferrer';
                        }
                        const fallbackLabel = (citation.title || 'Source').replace(/::/g, '|');
                        pill.textContent = `${index + 1}. ${fallbackLabel}`;
                        citationsRow.appendChild(pill);
                    });
                }
                
                const exportBtn = container.querySelector('.export-chat-btn');
                if (exportBtn) { container.insertBefore(citationsRow, exportBtn); } else { container.appendChild(citationsRow); }
            } catch (error) { console.error('Error loading citations:', error); }
        }
        
        async function loadEnrichment(query, container) {
            console.debug('[DEBUG] loadEnrichment called for query:', query);
            // Robust enrichment loader with deduplication: check if enrichments already exist from inline markdown
            try {
                const response = await fetch('/api/chat/enrich?q=' + encodeURIComponent(query));
                if (!response.ok) return;
                const enrichment = await response.json();
                console.debug('[DEBUG] Enrichment API response:', enrichment);

                const normalize = (arr) => (Array.isArray(arr) ? arr : [])
                    .map(v => (typeof v === 'string' ? v.trim() : ''))
                    .filter(v => v.length > 0);

                const hints = normalize(enrichment.hints);
                const background = normalize(enrichment.background);
                const reminders = normalize(enrichment.reminders);

                // CRITICAL: Check for existing enrichments to prevent duplicates
                const existingTypes = new Set();
                container.querySelectorAll('[data-enrichment-type]').forEach(el => {
                    existingTypes.add(el.getAttribute('data-enrichment-type'));
                });

                let appended = false;
                // Only append if this type doesn't already exist (from inline markdown)
                if (hints.length > 0 && !existingTypes.has('hint')) { 
                    container.appendChild(MU.createEnrichmentBlock('hint', 'Helpful Hints', hints)); 
                    appended = true; 
                }
                if (background.length > 0 && !existingTypes.has('background')) { 
                    container.appendChild(MU.createEnrichmentBlock('background', 'Background Context', background)); 
                    appended = true; 
                }
                if (reminders.length > 0 && !existingTypes.has('reminder')) { 
                    container.appendChild(MU.createEnrichmentBlock('reminder', 'Important Reminders', reminders)); 
                    appended = true; 
                }

                console.debug('[DEBUG] Enrichment cards appended:', appended, 'Existing types:', Array.from(existingTypes));
                // If nothing valid, do not create any placeholders
                if (!appended) return;
            } catch (error) {
                // Silently ignore to avoid UI artifacts
                console.debug('Enrichment load skipped:', error);
            }
        }
        
        // knowledge-card is deprecated; unified enrichment blocks are used instead.
        
        function copyMessage(text, button) { navigator.clipboard.writeText(text).then(() => { button.classList.add('copied'); const originalHTML = button.innerHTML; button.innerHTML = `<svg width=\"16\" height=\"16\" viewbox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg>`; setTimeout(() => { button.classList.remove('copied'); button.innerHTML = originalHTML; }, 2000); }).catch(() => { showToast('Failed to copy', 'error'); }); }

        function attachCodeCopyButtons(container) {
            try {
                const blocks = container.querySelectorAll('pre');
                blocks.forEach(pre => {
                    if (pre.querySelector('.code-copy-btn')) return;
                    const btn = document.createElement('button');
                    btn.className = 'code-copy-btn';
                    btn.setAttribute('aria-label', 'Copy code');
                    btn.title = 'Copy code';
                    btn.innerHTML = `<svg width=\"16\" height=\"16\" viewbox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                        <rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect>\n                        <path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path>\n                    </svg>`;
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const codeEl = pre.querySelector('code');
                        const text = codeEl ? codeEl.innerText : pre.innerText;
                        copyMessage(text, btn);
                    });
                    pre.appendChild(btn);
                });
            } catch (err) { console.warn('Failed to attach code copy buttons', err); }
        }
        
        /**
         * Safe code block upgrade function for chat.html
         * MINIMAL APPROACH: Only ensures proper structure, doesn't modify content
         * Prevents JavaScript errors while maintaining stable UI
         */
        function upgradeCodeBlocks(container) {
            try {
                // Safety check: if container is invalid, return silently
                if (!container || typeof container.querySelectorAll !== 'function') {
                    console.debug('upgradeCodeBlocks: Invalid container, skipping');
                    return;
                }
                
                // IMPORTANT: In chat.html context, we do NOT want to:
                // 1. Convert inline code to blocks (that's for guided learning)
                // 2. Wrap code blocks in enrichment containers
                // 3. Modify the structure that the server already created
                
                // We only ensure code blocks have proper language classes for Prism
                const codeBlocks = container.querySelectorAll('pre > code');
                codeBlocks.forEach(code => {
                    // If no language class, try to detect from content
                    if (!code.className || !code.className.includes('language-')) {
                        // Check if it looks like Java code
                        const text = code.textContent || '';
                        if (text.includes('public class') || text.includes('import java') || 
                            text.includes('public static void') || text.includes('HashMap')) {
                            code.className = 'language-java';
                        }
                    }
                });
                
                // Log for debugging but don't throw errors
                console.debug(`upgradeCodeBlocks: Processed ${codeBlocks.length} code blocks`);
                
            } catch (err) {
                // Fail silently to prevent breaking the UI
                console.debug('upgradeCodeBlocks: Non-critical error', err);
            }
        }
        
        async function copyChat() {
            try { const res = await fetch('/api/chat/export/session?sessionId=web'); const txt = await res.text(); await navigator.clipboard.writeText(txt); const btn = document.querySelector('.export-chat-btn'); if (btn) { btn.style.background = 'var(--accent-success)'; btn.style.color = 'white'; setTimeout(() => { btn.style.background = ''; btn.style.color = ''; }, 2000); } showToast('Chat session exported to clipboard!'); } catch (error) { showToast('Failed to export', 'error'); }
        }
        
        function cleanupEmptyElements(container) {
            // Remove any divs that are empty or only contain whitespace
            const allDivs = container.querySelectorAll('div');
            allDivs.forEach(div => {
                // Skip special elements
                if (div.classList.contains('loading-dots') || 
                    div.classList.contains('typing-cursor') ||
                    div.classList.contains('bubble') ||
                    div.classList.contains('streaming-text')) {
                    return;
                }
                
                // Remove if empty or only whitespace
                const text = div.textContent || '';
                if (text.trim() === '' && div.children.length === 0) {
                    div.remove();
                }
                
                // Remove knowledge cards without content
                if (div.classList.contains('knowledge-card')) {
                    const content = div.querySelector('.knowledge-card-content');
                    if (!content || !content.textContent || content.textContent.trim() === '') {
                        div.remove();
                    }
                }
                
                // Remove empty enrichment blocks
                if (div.classList.contains('inline-enrichment')) {
                    const enrichText = div.querySelector('.enrichment-text');
                    if (!enrichText || !enrichText.textContent || enrichText.textContent.trim() === '') {
                        div.remove();
                    }
                }
                
                // Remove empty citation rows
                if (div.classList.contains('citations-row') && div.children.length === 0) {
                    div.remove();
                }
            });
        }
        
        function showToast(message, type = 'success') { const toast = document.createElement('div'); toast.style.cssText = `position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; background: ${type === 'error' ? 'var(--accent-error)' : 'var(--accent-success)'}; color: white; border-radius: var(--radius-lg); box-shadow: var(--shadow-xl); z-index: 1000; animation: fadeIn 0.3s ease;`; toast.textContent = message; document.body.appendChild(toast); setTimeout(() => { toast.style.animation = 'fadeIn 0.3s ease reverse'; setTimeout(() => toast.remove(), 300); }, 3000); }
        
        document.addEventListener('DOMContentLoaded', () => {
            // Signal parent that DOM is ready (prevents skeleton overlay)
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'dom-ready' }, '*');
            }
            
            const input = document.getElementById('q');
            input.focus();
            document.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') { e.preventDefault(); input.focus(); input.select(); }
                if (e.key === 'Escape' && document.activeElement === input) { input.value = ''; }
            });
        });
    </script>
</body>
</html>
