<!doctype html>
<!-- htmlhint attr-lowercase:false -->
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Java Chat - Beautiful AI-Powered Java Learning</title>
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="icon" type="image/png" href="/favicon-196x196.png" sizes="196x196" />
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16" />
    <link rel="icon" type="image/png" href="/favicon-128.png" sizes="128x128" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="application-name" content="Java Chat"/>
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="msapplication-TileImage" content="/mstile-144x144.png" />
    <meta name="msapplication-square70x70logo" content="/mstile-70x70.png" />
    <meta name="msapplication-square150x150logo" content="/mstile-150x150.png" />
    <meta name="msapplication-wide310x150logo" content="/mstile-310x150.png" />
    <meta name="msapplication-square310x310logo" content="/mstile-310x310.png" />
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="/css/app.css" rel="stylesheet" />
    
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1 class="app-title">Java Chat</h1>
                <span class="pill">
                    <span class="status-indicator"></span>
                    JDK 24 Docs
                </span>
                <span class="pill">AI-Powered Learning</span>
            </div>
            <div class="header-right"></div>
        </div>
        
        <div id="chat" role="log" aria-live="polite" aria-label="Chat messages"></div>
        
        <button class="export-chat-btn" onclick="copyChat()" aria-label="Export entire chat" title="Export entire chat">
            <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2L12 14"></path>
                <polyline points="19 9 12 16 5 9"></polyline>
                <path d="M5 20h14"></path>
            </svg>
        </button>
        
        <div class="input-area">
            <div class="input-row">
                <div class="input-wrapper">
                    <input 
                        id="q" 
                        class="input" 
                        placeholder="Ask about Java - try 'What are records?' or 'Explain pattern matching'"
                        aria-label="Enter your Java question"
                        autocomplete="off"
                        onkeypress="if(event.key==='Enter') ask()"
                    />
                    <button class="btn" onclick="ask()" id="askBtn" aria-label="Send question">
                        <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Theme Toggle Placeholder (kept for parity) -->
    <button class="theme-toggle" style="display:none" aria-hidden="true"></button>
    
    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="/js/markdown-utils.js"></script>
    
    <script>
        // Enhanced streaming with character-by-character animation
        class StreamingText {
            constructor(element, text, speed = 30) { this.element = element; this.text = text; this.speed = speed; this.index = 0; }
            async stream() { const cursor = document.createElement('span'); cursor.className = 'typing-cursor'; this.element.appendChild(cursor); for (let i = 0; i < this.text.length; i++) { const char = this.text[i]; const textNode = document.createTextNode(char); this.element.insertBefore(textNode, cursor); await this.delay(1000 / this.speed); } cursor.remove(); }
            delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        }
        
        async function ask() {
            const input = document.getElementById('q');
            const q = input.value.trim();
            if (!q) return;
            
            const chatEl = document.getElementById('chat');
            const askBtn = document.getElementById('askBtn');
            
            // User bubble
            const userBubble = document.createElement('div');
            userBubble.className = 'bubble user';
            userBubble.textContent = q;
            const userCopyBtn = document.createElement('button');
            userCopyBtn.className = 'message-copy-btn';
            userCopyBtn.setAttribute('aria-label', 'Copy message');
            userCopyBtn.title = 'Copy message';
            userCopyBtn.innerHTML = `<svg width="16" height="16" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>`;
            userCopyBtn.onclick = () => copyMessage(q, userCopyBtn);
            userBubble.appendChild(userCopyBtn);
            chatEl.appendChild(userBubble);
            
            input.value = '';
            askBtn.disabled = true;
            
            // Assistant bubble
            const assistantBubble = document.createElement('div');
            assistantBubble.className = 'bubble assistant';
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading-dots';
            loadingDiv.innerHTML = `
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
            `;
            assistantBubble.appendChild(loadingDiv);
            chatEl.appendChild(assistantBubble);
            chatEl.scrollTop = chatEl.scrollHeight;
            
            try {
                const response = await fetch('/api/chat/stream', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ sessionId: 'web', latest: q }) });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                loadingDiv.remove();
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'streaming-text';
                assistantBubble.appendChild(contentWrapper);
                const cursor = document.createElement('span'); cursor.className = 'typing-cursor'; contentWrapper.appendChild(cursor);
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullText = '';
                let buffer = '';
                // Debounced rendering: reduce /api/markdown/render churn and jitter
                let renderTimer = null; let lastRendered = '';
                const flushRender = async () => { 
                    try { 
                        if (fullText === lastRendered) return; 
                        const formatted = await formatText(fullText); 
                        contentWrapper.innerHTML = formatted; 
                        
                        // Safe function calls with error handling
                        try {
                            upgradeCodeBlocks(contentWrapper);
                        } catch (err) {
                            console.debug('upgradeCodeBlocks error (non-critical):', err);
                        }
                        
                        try {
                            attachCodeCopyButtons(contentWrapper);
                        } catch (err) {
                            console.debug('attachCodeCopyButtons error (non-critical):', err);
                        }
                        
                        contentWrapper.appendChild(cursor);
                        
                        try { (window.MU?MU.safeHighlightUnder:Prism.highlightAllUnder)(contentWrapper); } catch (err) { console.debug('highlight error (non-critical):', err); }
                        
                        lastRendered = fullText; 
                        chatEl.scrollTop = chatEl.scrollHeight; 
                    } catch(err){
                        console.error('flushRender error:', err);
                    } 
                };
                const scheduleRender = (immediate=false) => { if (immediate) { if (renderTimer) { clearTimeout(renderTimer); renderTimer=null; } flushRender(); } else { if (renderTimer) clearTimeout(renderTimer); renderTimer = setTimeout(flushRender, 120); } };
                let firstChunk = false;
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;
                    const lines = buffer.split('\n');
                    buffer = lines[lines.length - 1];
                    for (let i = 0; i < lines.length - 1; i++) {
                        // Preserve literal spaces in SSE data payloads.
                        // Do NOT trim the line; only strip a trailing CR.
                        let line = lines[i];
                        if (line.endsWith('\r')) line = line.slice(0, -1);
                        if (line.startsWith('data:')) {
                            const data = line.slice(5); // keep any leading space after 'data:'
                            if (data.length) fullText += data;
                        }
                    }
                    // Decide whether to flush immediately based on sentence/paragraph/code boundaries
                    // IMPORTANT: Only treat a code-fence boundary as complete when followed by a newline
                    // to avoid rendering half-fences like "```javaimport ..." inline.
                    const immediate = window.MU ? MU.shouldImmediateFlush(fullText) : (/[.!?][\"')]*\s$/.test(fullText.slice(-4)) || /\n\n/.test(fullText.slice(-2)) || fullText.endsWith('```\n'));
                    scheduleRender(immediate);
                    if (!firstChunk) {
                        firstChunk = true;
                        try { window.parent.postMessage({ type: 'content-started' }, '*'); } catch(_){}
                    }
                }
                // Final flush
                await flushRender();
                cursor.remove();
                const assistantCopyBtn = document.createElement('button');
                assistantCopyBtn.className = 'message-copy-btn';
                assistantCopyBtn.setAttribute('aria-label', 'Copy assistant response');
                assistantCopyBtn.title = 'Copy assistant response';
                assistantCopyBtn.innerHTML = `<svg width="16" height="16" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>`;
                assistantCopyBtn.onclick = () => copyMessage(fullText, assistantCopyBtn);
                assistantBubble.appendChild(assistantCopyBtn);
                Prism.highlightAllUnder(assistantBubble);
                attachCodeCopyButtons(assistantBubble);
                await loadCitations(q, assistantBubble);
                await loadEnrichment(q, assistantBubble);
                
                // CRITICAL: Clean up any empty elements that might create visual artifacts
                cleanupEmptyElements(chatEl);
            } catch (error) {
                console.error('Streaming error:', error);
                assistantBubble.innerHTML = `<div style="color: var(--accent-error);">‚ö†Ô∏è Error: Failed to get response. Please try again.</div>`;
            } finally { askBtn.disabled = false; input.focus(); }
        }
        
        /**
         * FALLBACK-AWARE: Markdown rendering with server-side support and a minimal client-side fallback.
         * Source of truth: com.williamcallahan.javachat.service.MarkdownService (server).
         * If the server endpoint /api/markdown/render fails, we use a BASIC client parser
         * solely to maintain readability (paragraphs, UL/OL, inline code, fenced code).
         * Keep this fallback aligned with server logic:
         *   - preprocessMarkdown()
         *   - applySmartParagraphBreaksImproved()
         *   - fixInlineLists()
         *   - protectCodeBlocks()
         *   - restoreEnrichments()
         *   - render()
         * IMPORTANT: Always fix/extend server behavior first. The fallback is intentionally limited.
         */
        async function formatText(text, useServerMarkdown = true) {
            if (useServerMarkdown) {
                try {
                    const response = await fetch('/api/markdown/render', { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ content: text }) 
                    });
                    if (response.ok) { 
                        const data = await response.json(); 
                        return applyCustomEnrichments(data.html); 
                    }
                    console.error('Server markdown failed with status:', response.status);
                } catch (error) { 
                    console.error('Server markdown error:', error); 
                }
            }
            // Safety net: preserve enrichments, do minimal client markdown, then restore and enrich
            const preserved = preserveEnrichments(text);
            const html = clientMarkdownFallback(preserved);
            const restored = restoreEnrichments(html);
            return applyCustomEnrichments(restored);
        }
        
        function applyCustomEnrichments(text) {
            console.debug('[DEBUG] applyCustomEnrichments called with text length:', text.length);
            // CRITICAL: Only create enrichment divs if content is not empty!
            text = text.replace(/\{\{hint:([\s\S]*?)\}\}/g, (m, c) => {
                const content = c.trim();
                console.debug('[DEBUG] Processing inline hint:', content.substring(0, 50) + (content.length > 50 ? '...' : ''));
                return content ? `\n<div class="inline-enrichment hint"><div class="inline-enrichment-header"><svg viewbox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg><span>Helpful Hint</span></div><div class="enrichment-text">${content}</div></div>\n` : '';
            });
            text = text.replace(/\{\{reminder:([\s\S]*?)\}\}/g, (m, c) => {
                const content = c.trim();
                console.debug('[DEBUG] Processing inline reminder:', content.substring(0, 50) + (content.length > 50 ? '...' : ''));
                return content ? `\n<div class="inline-enrichment reminder"><div class="inline-enrichment-header"><svg viewbox="0 0 24 24" fill="currentColor"><path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"/></svg><span>Important Reminder</span></div><div class="enrichment-text">${content}</div></div>\n` : '';
            });
            text = text.replace(/\{\{background:([\s\S]*?)\}\}/g, (m, c) => {
                const content = c.trim();
                console.debug('[DEBUG] Processing inline background:', content.substring(0, 50) + (content.length > 50 ? '...' : ''));
                return content ? `\n<div class="inline-enrichment background"><div class="inline-enrichment-header"><svg viewbox="0 0 24 24" fill="currentColor"><path d="M3 3h18v2H3zM3 7h18v2H3zM3 11h18v2H3z"/></svg><span>Background Context</span></div><div class="enrichment-text">${content}</div></div>\n` : '';
            });
            text = text.replace(/\{\{example:([\s\S]*?)\}\}/g, (m, c) => {
                const content = c.trim();
                return content ? `\n<div class="inline-example"><div class="example-header">Example</div><pre><code class="language-java">${escapeHtml(content)}</code></pre></div>\n` : '';
            });
            text = text.replace(/\{\{warning:([\s\S]*?)\}\}/g, (m, c) => {
                const content = c.trim();
                return content ? `\n<div class="inline-enrichment warning"><div class="inline-enrichment-header"><svg viewbox="0 0 24 24" fill="currentColor"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg><span>Warning</span></div><div class="enrichment-text">${content}</div></div>\n` : '';
            });
            text = text.replace(/\[(\d+)\]/g, (m, n) => `<sup class="inline-citation" data-cite="${n}">[${n}]</sup>`);
            
            // Remove any stray empty enrichment patterns
            text = text.replace(/\{\{\w+:\s*\}\}/g, '');
            
            return text;
        }
        
        function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }

        /**
         * FALLBACK: Preserve custom enrichment blocks while client-side parsing.
         * Mirrors server placeholders in MarkdownService.preserveEnrichments().
         * Focus fixes on server first; keep placeholder format in sync with server.
         */
        function preserveEnrichments(text) {
            return text.replace(/\{\{(hint|reminder|background|example|warning):([\s\S]*?)\}\}/g, (m, t, c) => `ZZENRICHZ${t}ZSTARTZZZ${c}ZZENRICHZ${t}ZENDZZZ`);
        }
        /**
         * FALLBACK: Restore enrichment placeholders back to {{type:content}} after client parse.
         * Mirrors MarkdownService.restoreEnrichments(). Keep in sync with server format.
         */
        function restoreEnrichments(html) {
            return html.replace(/ZZENRICHZ(\w+)ZSTARTZZZ([\s\S]*?)ZZENRICHZ\1ZENDZZZ/g, (m, t, c) => `{{${t}:${c}}}`);
        }

        /**
         * Safe code block upgrade function for chat.html
         * CONSERVATIVE: Only ensures proper language classes for syntax highlighting
         * Does NOT modify structure to avoid regressions
         */
        function upgradeCodeBlocks(container) {
            try {
                // Safety check: if container is invalid, return silently
                if (!container || typeof container.querySelectorAll !== 'function') {
                    console.debug('upgradeCodeBlocks: Invalid container, skipping');
                    return;
                }
                
                // CRITICAL: We do NOT convert inline code to blocks
                // The server-side markdown parser already handles this distinction
                // Converting multi-line inline code to blocks causes the exact issue we're fixing
                
                // Only ensure code blocks have proper language classes for Prism.js
                const codeBlocks = container.querySelectorAll('pre > code');
                codeBlocks.forEach(code => {
                    // If no language class, try to detect from content
                    if (!code.className || !code.className.includes('language-')) {
                        const text = code.textContent || '';
                        // Check for Java code patterns
                        if (text.includes('public class') || text.includes('import java') || 
                            text.includes('public static void') || text.includes('HashMap') ||
                            text.includes('String') || text.includes('System.out') ||
                            text.includes('Integer') || text.includes('ArrayList')) {
                            code.className = 'language-java';
                        }
                    }
                });
                
                // CRITICAL: We do NOT wrap pre blocks in enrichment containers
                // This causes the rendering issue where code appears inline
                // The server decides when to wrap code in special containers
                
                console.debug(`upgradeCodeBlocks: Processed ${codeBlocks.length} code blocks safely`);
                
            } catch (err) {
                // Fail silently to prevent breaking the UI
                console.debug('upgradeCodeBlocks: Non-critical error', err);
            }
        }

        /**
         * FALLBACK: Minimal, safe client markdown renderer.
         * Purpose: readability if /api/markdown/render is unavailable.
         * Scope: paragraphs, UL/OL, inline code, fenced code (escaped). No advanced GFM.
         * Keep behavior broadly aligned with server MarkdownService preprocessing, but do not
         * attempt full parity. Always prioritize server-side rendering for correctness.
         */
        function clientMarkdownFallback(text) {
            if (!text) return '';
            if (window.MU) { text = MU.normalizeOpeningFences(text); text = MU.promoteLikelyJavaBlocks(text); }
            // Extract fenced code blocks and replace with placeholders
            const codeBlocks = [];
            let s = text.replace(/```([\w-]+)?\n([\s\S]*?)\n```/g, (m, lang, code) => {
                const idx = codeBlocks.push({ lang: (lang||'').trim(), code: code.trim() }) - 1;
                return `[[CODE_BLOCK_${idx}]]`;
            });

            // Normalize inline list markers frequently produced by models
            s = s.replace(/(:)\s*-\s+(?=\S)/g, '$1\n\n- ');
            s = s.replace(/([.!?])\s+(\d+\.\s+)/g, '$1\n$2');

            // Escape HTML globally
            s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // Inline code
            s = s.replace(/`([^`]+)`/g, (m, c) => `<code>${escapeHtml(c)}</code>`);

            // Minimal headings (fallback only)
            s = s.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>')
                 .replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>')
                 .replace(/^####\s+(.+)$/gm, '<h4>$1</h4>')
                 .replace(/^###\s+(.+)$/gm, '<h3>$1</h3>')
                 .replace(/^##\s+(.+)$/gm, '<h2>$1</h2>')
                 .replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');

            const lines = s.split(/\r?\n/);
            let out = '';
            let inUl = false, inOl = false, para = '';
            const closeLists = () => { if (inUl) { out += '</ul>'; inUl = false; } if (inOl) { out += '</ol>'; inOl = false; } };
            const flushPara = () => { if (para.trim()) { out += `<p>${para.trim()}</p>`; } para = ''; };

            for (let raw of lines) {
                const line = raw.replace(/\s+$/, '');
                const codePh = line.match(/^\[\[CODE_BLOCK_(\d+)\]\]$/);
                if (codePh) {
                    flushPara(); closeLists();
                    const idx = parseInt(codePh[1], 10);
                    const blk = codeBlocks[idx] || { lang: '', code: '' };
                    const escaped = escapeHtml(blk.code);
                    const langClass = blk.lang ? ` class="language-${blk.lang}"` : '';
                    out += `<pre><code${langClass}>${escaped}</code></pre>`;
                    continue;
                }

                if (/^\s*$/.test(line)) { // blank line
                    flushPara(); closeLists();
                    continue;
                }
                if (/^-\s+/.test(line)) {
                    flushPara();
                    if (!inUl) { closeLists(); out += '<ul>'; inUl = true; }
                    out += `<li>${line.replace(/^-\s+/, '')}</li>`;
                    continue;
                }
                if (/^\d+\.\s+/.test(line)) {
                    flushPara();
                    if (!inOl) { closeLists(); out += '<ol>'; inOl = true; }
                    out += `<li>${line.replace(/^\d+\.\s+/, '')}</li>`;
                    continue;
                }
                // paragraph continuation
                para += (para ? ' ' : '') + line;
            }
            flushPara(); closeLists();

            // Reinsert fenced code blocks (already escaped)
            out = out.replace(/\[\[CODE_BLOCK_(\d+)\]\]/g, (m, i) => {
                const idx = parseInt(i, 10);
                const blk = codeBlocks[idx] || { lang: '', code: '' };
                const escaped = escapeHtml(blk.code);
                const langClass = blk.lang ? ` class=\"language-${blk.lang}\"` : '';
                return `<pre><code${langClass}>${escaped}</code></pre>`;
            });
            return out;
        }
        
        async function loadCitations(query, container) {
            try {
                const response = await fetch('/api/chat/citations?q=' + encodeURIComponent(query));
                if (!response.ok) return;
                const citations = await response.json();
                if (!citations || citations.length === 0) return;
                const citationsRow = document.createElement('div'); citationsRow.className = 'citations-row';
                citations.slice(0, 5).forEach((citation, index) => {
                    const href = citation.url || '';
                    const isHttpLink = href.startsWith('http://') || href.startsWith('https://');
                    const isLocalLink = href.startsWith('/');
                    const isPdf = href.toLowerCase().endsWith('.pdf');
                    const isLink = !!href && (isHttpLink || isLocalLink);
                    const pill = document.createElement(isLink ? 'a' : 'div'); pill.className = 'citation-pill' + (isPdf ? ' citation-pill-pdf' : '');
                    if (isLink) { pill.href = href; pill.target = '_blank'; pill.rel = 'noopener noreferrer'; }
                    let label = citation.title || 'Source';
                    if (!citation.title && isHttpLink) { try { label = new URL(href).hostname; } catch (_) {} }
                    const iconExternal = `<svg class=\"citation-icon\" viewbox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"></path><polyline points=\"15 3 21 3 21 9\"></polyline><line x1=\"10\" y1=\"14\" x2=\"21\" y2=\"3\"></line></svg>`;
                    const iconPdf = `<svg class=\"citation-icon\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M6 2h9l5 5v15a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8 1.5V8h4.5\"/><path d=\"M7 15h2.5a2 2 0 0 0 0-4H7v4zm5-4h1v4h-1a2 2 0 0 1-2-2v0a2 2 0 0 1 2-2zm5 0h-2v4h2\"/></svg>`;
                    pill.innerHTML = `<span class=\"citation-number\">${index + 1}</span><span class=\"citation-label\">${label}${isPdf ? ' (PDF)' : ''}</span>${isLink ? (isPdf ? iconPdf : iconExternal) : ''}`;
                    citationsRow.appendChild(pill);
                });
                const exportBtn = container.querySelector('.export-chat-btn');
                if (exportBtn) { container.insertBefore(citationsRow, exportBtn); } else { container.appendChild(citationsRow); }
            } catch (error) { console.error('Error loading citations:', error); }
        }
        
        async function loadEnrichment(query, container) {
            console.debug('[DEBUG] loadEnrichment called for query:', query);
            // Robust enrichment loader: append nothing unless there are real items
            try {
                const response = await fetch('/api/chat/enrich?q=' + encodeURIComponent(query));
                if (!response.ok) return;
                const enrichment = await response.json();
                console.debug('[DEBUG] Enrichment API response:', enrichment);

                const normalize = (arr) => (Array.isArray(arr) ? arr : [])
                    .map(v => (typeof v === 'string' ? v.trim() : ''))
                    .filter(v => v.length > 0);

                const hints = normalize(enrichment.hints);
                const background = normalize(enrichment.background);
                const reminders = normalize(enrichment.reminders);

                console.debug('[DEBUG] Normalized enrichment counts - hints:', hints.length, 'background:', background.length, 'reminders:', reminders.length);

                let appended = false;
                if (hints.length > 0) { container.appendChild(createKnowledgeCard('tip', 'üí° Helpful Hints', hints)); appended = true; }
                if (background.length > 0) { container.appendChild(createKnowledgeCard('background', 'üìö Background Context', background)); appended = true; }
                if (reminders.length > 0) { container.appendChild(createKnowledgeCard('insight', 'üîî Important Reminders', reminders)); appended = true; }

                console.debug('[DEBUG] Enrichment cards appended:', appended);
                // If nothing valid, do not create any placeholders
                if (!appended) return;
            } catch (error) {
                // Silently ignore to avoid UI artifacts
                console.debug('Enrichment load skipped:', error);
            }
        }
        
        function createKnowledgeCard(type, title, items) {
            const card = document.createElement('div'); card.className = `knowledge-card type-${type}`; card.style.position = 'relative';
            const header = document.createElement('div'); header.className = 'knowledge-card-header'; header.onclick = () => card.classList.toggle('expanded');
            const titleEl = document.createElement('div'); titleEl.className = 'knowledge-card-title'; titleEl.innerHTML = `<span>${title}</span><svg width=\"20\" height=\"20\" viewbox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polyline points=\"6 9 12 15 18 9\"></polyline></svg>`; header.appendChild(titleEl);
            const content = document.createElement('div'); content.className = 'knowledge-card-content'; content.innerHTML = '<ul>' + items.map(item => `<li>${item}</li>`).join('') + '</ul>';
            const copyBtn = document.createElement('button'); copyBtn.className = 'message-copy-btn'; copyBtn.style.top = 'var(--space-2)'; copyBtn.innerHTML = `<svg width=\"16\" height=\"16\" viewbox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect><path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path></svg>`; const cardText = `${title}\n${items.join('\n')}`; copyBtn.onclick = (e) => { e.stopPropagation(); copyMessage(cardText, copyBtn); };
            card.appendChild(header); card.appendChild(content); card.appendChild(copyBtn); return card;
        }
        
        function copyMessage(text, button) { navigator.clipboard.writeText(text).then(() => { button.classList.add('copied'); const originalHTML = button.innerHTML; button.innerHTML = `<svg width=\"16\" height=\"16\" viewbox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg>`; setTimeout(() => { button.classList.remove('copied'); button.innerHTML = originalHTML; }, 2000); }).catch(() => { showToast('Failed to copy', 'error'); }); }

        function attachCodeCopyButtons(container) {
            try {
                const blocks = container.querySelectorAll('pre');
                blocks.forEach(pre => {
                    if (pre.querySelector('.code-copy-btn')) return;
                    const btn = document.createElement('button');
                    btn.className = 'code-copy-btn';
                    btn.setAttribute('aria-label', 'Copy code');
                    btn.title = 'Copy code';
                    btn.innerHTML = `<svg width=\"16\" height=\"16\" viewbox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                        <rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect>\n                        <path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path>\n                    </svg>`;
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const codeEl = pre.querySelector('code');
                        const text = codeEl ? codeEl.innerText : pre.innerText;
                        copyMessage(text, btn);
                    });
                    pre.appendChild(btn);
                });
            } catch (err) { console.warn('Failed to attach code copy buttons', err); }
        }
        
        /**
         * Safe code block upgrade function for chat.html
         * MINIMAL APPROACH: Only ensures proper structure, doesn't modify content
         * Prevents JavaScript errors while maintaining stable UI
         */
        function upgradeCodeBlocks(container) {
            try {
                // Safety check: if container is invalid, return silently
                if (!container || typeof container.querySelectorAll !== 'function') {
                    console.debug('upgradeCodeBlocks: Invalid container, skipping');
                    return;
                }
                
                // IMPORTANT: In chat.html context, we do NOT want to:
                // 1. Convert inline code to blocks (that's for guided learning)
                // 2. Wrap code blocks in enrichment containers
                // 3. Modify the structure that the server already created
                
                // We only ensure code blocks have proper language classes for Prism
                const codeBlocks = container.querySelectorAll('pre > code');
                codeBlocks.forEach(code => {
                    // If no language class, try to detect from content
                    if (!code.className || !code.className.includes('language-')) {
                        // Check if it looks like Java code
                        const text = code.textContent || '';
                        if (text.includes('public class') || text.includes('import java') || 
                            text.includes('public static void') || text.includes('HashMap')) {
                            code.className = 'language-java';
                        }
                    }
                });
                
                // Log for debugging but don't throw errors
                console.debug(`upgradeCodeBlocks: Processed ${codeBlocks.length} code blocks`);
                
            } catch (err) {
                // Fail silently to prevent breaking the UI
                console.debug('upgradeCodeBlocks: Non-critical error', err);
            }
        }
        
        async function copyChat() {
            try { const res = await fetch('/api/chat/export/session?sessionId=web'); const txt = await res.text(); await navigator.clipboard.writeText(txt); const btn = document.querySelector('.export-chat-btn'); if (btn) { btn.style.background = 'var(--accent-success)'; btn.style.color = 'white'; setTimeout(() => { btn.style.background = ''; btn.style.color = ''; }, 2000); } showToast('Chat session exported to clipboard!'); } catch (error) { showToast('Failed to export', 'error'); }
        }
        
        function cleanupEmptyElements(container) {
            // Remove any divs that are empty or only contain whitespace
            const allDivs = container.querySelectorAll('div');
            allDivs.forEach(div => {
                // Skip special elements
                if (div.classList.contains('loading-dots') || 
                    div.classList.contains('typing-cursor') ||
                    div.classList.contains('bubble') ||
                    div.classList.contains('streaming-text')) {
                    return;
                }
                
                // Remove if empty or only whitespace
                const text = div.textContent || '';
                if (text.trim() === '' && div.children.length === 0) {
                    div.remove();
                }
                
                // Remove knowledge cards without content
                if (div.classList.contains('knowledge-card')) {
                    const content = div.querySelector('.knowledge-card-content');
                    if (!content || !content.textContent || content.textContent.trim() === '') {
                        div.remove();
                    }
                }
                
                // Remove empty enrichment blocks
                if (div.classList.contains('inline-enrichment')) {
                    const enrichText = div.querySelector('.enrichment-text');
                    if (!enrichText || !enrichText.textContent || enrichText.textContent.trim() === '') {
                        div.remove();
                    }
                }
                
                // Remove empty citation rows
                if (div.classList.contains('citations-row') && div.children.length === 0) {
                    div.remove();
                }
            });
        }
        
        function showToast(message, type = 'success') { const toast = document.createElement('div'); toast.style.cssText = `position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; background: ${type === 'error' ? 'var(--accent-error)' : 'var(--accent-success)'}; color: white; border-radius: var(--radius-lg); box-shadow: var(--shadow-xl); z-index: 1000; animation: fadeIn 0.3s ease;`; toast.textContent = message; document.body.appendChild(toast); setTimeout(() => { toast.style.animation = 'fadeIn 0.3s ease reverse'; setTimeout(() => toast.remove(), 300); }, 3000); }
        
        document.addEventListener('DOMContentLoaded', () => {
            // Signal parent that DOM is ready (prevents skeleton overlay)
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'dom-ready' }, '*');
            }
            
            const input = document.getElementById('q');
            input.focus();
            document.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') { e.preventDefault(); input.focus(); input.select(); }
                if (e.key === 'Escape' && document.activeElement === input) { input.value = ''; }
            });
        });
    </script>
</body>
</html>
