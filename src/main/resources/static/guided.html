<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Guided Learning</title>
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png" />
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
  <link rel="icon" type="image/png" href="/favicon-196x196.png" sizes="196x196" />
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="/favicon-128.png" sizes="128x128" />
  <link rel="icon" href="/favicon.ico" />
  <meta name="application-name" content="Java Chat"/>
  <meta name="msapplication-TileColor" content="#FFFFFF" />
  <meta name="msapplication-TileImage" content="/mstile-144x144.png" />
  <meta name="msapplication-square70x70logo" content="/mstile-70x70.png" />
  <meta name="msapplication-square150x150logo" content="/mstile-150x150.png" />
  <meta name="msapplication-wide310x150logo" content="/mstile-310x150.png" />
  <meta name="msapplication-square310x310logo" content="/mstile-310x310.png" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <link href="/css/app.css" rel="stylesheet" />
</head>
<body class="guided-learning">
  <div class="container">
    <div class="header">
        <div class="header-left">
            <h1 class="app-title">Guided Learning</h1>
        </div>
    </div>

    <div class="lesson-selector">
        <button id="prevBtn" aria-label="Previous lesson">
            <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
        </button>
        <select id="lessonSelect" aria-label="Lesson selector"></select>
        <button id="nextBtn" aria-label="Next lesson">
            <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
        </button>
    </div>

    <!-- Main content area -->
    <div id="lesson-container">
        <div id="lessonSummary" class="muted" style="margin-bottom: var(--space-4);"></div>

        <div id="lessonSkeleton" class="skeleton-loader hidden" aria-hidden="true">
            <div class="skeleton-loader title"></div>
            <div class="skeleton-loader text"></div>
            <div class="skeleton-loader text short"></div>
        </div>

        <div id="lessonContentWrapper">
            <div id="citations" class="citations-row" aria-label="Citations"></div>
            <div id="lessonContent" class="lesson-content" aria-live="polite"></div>
            <div id="enrichment" style="margin-top: 12px"></div>
        </div>
    </div>

    <div id="guidedChat">
        <div id="chatArea" aria-live="polite" aria-label="Guided chat messages"></div>
        <div class="input-area">
            <div class="input-row">
                <div class="input-wrapper">
                    <input id="q" class="input" placeholder="Ask a question about this lesson" onkeypress="if(event.key==='Enter') ask()"/>
                    <button id="askBtn" class="btn" onclick="ask()" aria-label="Send question">
                        <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script>
    let toc = [];
    let currentIndex = 0;
    let glossary = [];
    let currentLoadId = 0;
    let activeControllers = [];

    function cancelActiveControllers(){
      activeControllers.forEach(c => { try { c.abort(); } catch(_){} });
      activeControllers = [];
    }

    function setLessonLoading(isLoading){
      const sk = document.getElementById('lessonSkeleton');
      const prev = document.getElementById('prevBtn');
      const next = document.getElementById('nextBtn');
      const ask = document.getElementById('askBtn');
      sk.classList.toggle('hidden', !isLoading);
      prev.disabled = isLoading || prev.disabled;
      next.disabled = isLoading || next.disabled;
      ask.disabled = isLoading || ask.disabled;
    }

    async function loadTOC() {
      setLessonLoading(true);
      const res = await fetch('/api/guided/toc');
      toc = await res.json();
      // Fetch tooltips glossary once
      try { const gres = await fetch('/api/tooltips/list'); if (gres.ok) glossary = await gres.json(); } catch(_){}
      const sel = document.getElementById('lessonSelect');
      sel.innerHTML = '';
      toc.forEach((l, i) => {
        const opt = document.createElement('option');
        opt.value = l.slug; opt.textContent = l.title; sel.appendChild(opt);
      });
      sel.onchange = () => {
        currentIndex = Math.max(0, toc.findIndex(l => l.slug === sel.value));
        loadLesson(toc[currentIndex].slug);
      };
      if (toc.length > 0) {
        currentIndex = 0;
        sel.value = toc[0].slug;
        await loadLesson(toc[0].slug);
      }
      document.getElementById('prevBtn').onclick = prevLesson;
      document.getElementById('nextBtn').onclick = nextLesson;
      updateNavButtons();
      setLessonLoading(false);
    }

    function prevLesson() { if (currentIndex > 0) { currentIndex--; selectByIndex(); } }
    function nextLesson() { if (currentIndex < toc.length - 1) { currentIndex++; selectByIndex(); } }
    function selectByIndex() { const sel = document.getElementById('lessonSelect'); sel.value = toc[currentIndex].slug; loadLesson(toc[currentIndex].slug); updateNavButtons(); }
    function updateNavButtons() { document.getElementById('prevBtn').disabled = currentIndex === 0; document.getElementById('nextBtn').disabled = currentIndex === toc.length - 1; }

    async function loadLesson(slug) {
      // Cancel any in-flight fetch/streams and clear UI immediately
      cancelActiveControllers();
      const wrap = document.getElementById('citations');
      const content = document.getElementById('lessonContent');
      const enrich = document.getElementById('enrichment');
      const chatArea = document.getElementById('chatArea');
      wrap.innerHTML = '';
      content.innerHTML = '';
      enrich.innerHTML = '';
      chatArea.innerHTML = '';
      setLessonLoading(true);
      currentLoadId++;
      const loadId = currentLoadId;
      try {
        const res = await fetch('/api/guided/lesson?slug=' + encodeURIComponent(slug));
        const lesson = await res.json();
        document.getElementById('lessonSummary').textContent = lesson.summary || '';
        await Promise.all([
          loadCitations(slug, loadId),
          loadLessonContent(slug, loadId),
          loadEnrichment(slug, loadId)
        ]);
      } finally {
        setLessonLoading(false);
      }
    }

    async function loadLessonContent(slug, loadId){
      const el = document.getElementById('lessonContent');
      el.innerHTML = '';
      try {
        const controller = new AbortController();
        activeControllers.push(controller);
        const response = await fetch('/api/guided/content/stream?slug=' + encodeURIComponent(slug), { signal: controller.signal });
        if (!response.ok) { el.textContent = 'Failed to load lesson content.'; return; }
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullText = '';
        let buffer = '';
        let firstChunkShown = false;
        // Debounced rendering for smoother lesson updates
        let renderTimer = null; let lastRendered = '';
        const flushRender = async () => { 
          try { 
            if (loadId !== currentLoadId) return; 
            if (fullText === lastRendered) return; 
            const html = await renderMarkdown(fullText); 
            el.innerHTML = html; 
            
            // Safe function calls with error handling
            try {
              upgradeCodeBlocks(el);
            } catch (err) {
              console.debug('upgradeCodeBlocks error (non-critical):', err);
            }
            
            try { (window.MU?MU.attachCodeCopyButtons:()=>{})(el); } catch (err) { console.debug('attachCodeCopyButtons error (non-critical):', err); }
            try { (window.MU?MU.safeHighlightUnder:Prism.highlightAllUnder)(el); } catch (err) { console.debug('highlight error (non-critical):', err); }
            
            try {
              applyGlossaryTooltips(el);
            } catch (err) {
              console.debug('Glossary tooltips error (non-critical):', err);
            }
            
            lastRendered = fullText; 
          } catch(err){
            console.error('flushRender error:', err);
          } 
        };
        const scheduleRender = (immediate=false) => { if (immediate) { if (renderTimer) { clearTimeout(renderTimer); renderTimer=null; } flushRender(); } else { if (renderTimer) clearTimeout(renderTimer); renderTimer = setTimeout(flushRender, 120); } };
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          buffer += chunk;
          const lines = buffer.split('\n');
          buffer = lines[lines.length - 1];
          for (let i = 0; i < lines.length - 1; i++) {
            const line = lines[i].trim();
            if (line.startsWith('data:')) {
              const data = line.substring(5);
              if (data.trim()) fullText += data;
            }
          }
          // If user switched lessons, drop work
          if (loadId !== currentLoadId) return;
          // Only treat a code-fence boundary as complete when followed by a newline
          const immediate = window.MU ? MU.shouldImmediateFlush(fullText) : (/[.!?][\"')]*\s$/.test(fullText.slice(-4)) || /\n\n/.test(fullText.slice(-2)) || fullText.endsWith('```\n'));
          scheduleRender(immediate);
          if (!firstChunkShown) {
            firstChunkShown = true;
            setLessonLoading(false);
            // Inform parent to hide top loader immediately
            try { window.parent.postMessage({ type: 'content-started' }, '*'); } catch(_){}
          }
        }
        await flushRender();
      } catch (_) {
        el.textContent = 'Error streaming lesson content.';
      }
    }

    function applyGlossaryTooltips(container){
      if (!glossary || glossary.length === 0) return;
      const maxTooltips = 5; let applied = 0;
      const terms = glossary.map(g => ({ term: g.term || g.term, def: g.definition || g.definition, link: g.link || g.link }));
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
      const nodes = [];
      while (walker.nextNode()) nodes.push(walker.currentNode);
      for (const node of nodes) {
        if (applied >= maxTooltips) break;
        const parent = node.parentElement;
        if (!parent) continue;
        const tag = parent.tagName.toLowerCase();
        if (tag === 'code' || tag === 'pre' || tag === 'a') continue;
        let text = node.nodeValue;
        for (const t of terms) {
          if (applied >= maxTooltips) break;
          const re = new RegExp('\\b' + escapeRegExp(t.term) + '\\b','i');
          if (re.test(text)) {
            const span = document.createElement('span');
            const replaced = text.replace(re, (m)=>`<abbr title="${escapeHtml(t.def)}">${m}</abbr>`);
            span.innerHTML = replaced;
            parent.replaceChild(span, node);
            applied++;
            break;
          }
        }
      }
    }
    function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
    function escapeHtml(s){
      const d = document.createElement('div'); d.textContent = s; return d.innerHTML;
    }

    async function loadCitations(slug, loadId) {
      const wrap = document.getElementById('citations'); wrap.innerHTML = '';
      const controller = new AbortController();
      activeControllers.push(controller);
      const res = await fetch('/api/guided/citations?slug=' + encodeURIComponent(slug), { signal: controller.signal });
      const citations = await res.json();
      if (loadId !== currentLoadId) return;
      (citations || []).slice(0,5).forEach((c, i) => {
        const a = document.createElement(c.url ? 'a' : 'div');
        a.className = 'citation-pill';
        if (c.url) { a.href = c.url; a.target = '_blank'; a.rel = 'noopener noreferrer'; }
        a.textContent = `${i+1}. ${c.title || 'Source'}`;
        wrap.appendChild(a);
      });
    }

    async function loadEnrichment(slug, loadId) {
      const div = document.getElementById('enrichment'); div.innerHTML = '';
      const controller = new AbortController();
      activeControllers.push(controller);
      const res = await fetch('/api/guided/enrich?slug=' + encodeURIComponent(slug), { signal: controller.signal });
      if (!res.ok) return; const enrichment = await res.json();
      if (loadId !== currentLoadId) return;

      // Use the same rendering logic as chat.html for a consistent look and feel
      const createEnrichmentBlock = (type, title, svgPath, items) => {
        const normalized = (Array.isArray(items) ? items : [])
          .map(t => (typeof t === 'string' ? t.trim() : ''))
          .filter(t => t.length > 0);
        if (normalized.length === 0) return;

        const card = document.createElement('div');
        card.className = `inline-enrichment ${type}`;
        
        const header = document.createElement('div');
        header.className = 'inline-enrichment-header';
        header.innerHTML = `<svg viewbox="0 0 24 24" fill="currentColor">${svgPath}</svg><span>${title}</span>`;
        
        const body = document.createElement('div');
        body.className = 'enrichment-text';
        body.innerHTML = normalized.map(item => `<p>${item}</p>`).join('');

        card.appendChild(header);
        card.appendChild(body);
        div.appendChild(card);
      };

      createEnrichmentBlock(
        'hint', 'Helpful Hints',
        '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>',
        enrichment.hints
      );
      createEnrichmentBlock(
        'background', 'Background Context',
        '<path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/>',
        enrichment.background
      );
      createEnrichmentBlock(
        'reminder', 'Important Reminders',
        '<path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"/>',
        enrichment.reminders
      );
    }

    async function ask() {
      const input = document.getElementById('q'); const q = input.value.trim(); if (!q) return;
      const lesson = toc[currentIndex]; const slug = lesson.slug;
      const chatArea = document.getElementById('chatArea'); const askBtn = document.getElementById('askBtn');
      // user bubble
      const ub = document.createElement('div'); ub.className = 'bubble user'; ub.textContent = q; chatArea.appendChild(ub);
      input.value=''; askBtn.disabled=true;
      // assistant bubble
      const ab = document.createElement('div'); ab.className = 'bubble assistant'; chatArea.appendChild(ab);
      const content = document.createElement('div'); content.className = 'streaming-text'; ab.appendChild(content); const cursor=document.createElement('span'); cursor.className='typing-cursor'; content.appendChild(cursor);
      try {
        const response = await fetch('/api/guided/stream', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ sessionId: 'guided:'+slug, slug, latest: q }) });
        if (!response.ok) throw new Error('HTTP '+response.status);
        const reader = response.body.getReader(); const decoder = new TextDecoder(); let fullText=''; let buffer='';
        let renderTimer=null; let lastRendered='';
        const flushRender = async () => { 
          try { 
            if (fullText === lastRendered) return; 
            const html = await renderMarkdown(fullText); 
            content.innerHTML = html; 
            
            // Safe function calls with error handling
            try {
              upgradeCodeBlocks(content);
            } catch (err) {
              console.debug('upgradeCodeBlocks error (non-critical):', err);
            }
            
            try {
              attachCodeCopyButtons(content);
            } catch (err) {
              console.debug('attachCodeCopyButtons error (non-critical):', err);
            }
            
            content.appendChild(cursor);
            try { (window.MU?MU.safeHighlightUnder:Prism.highlightAllUnder)(content); } catch (err) { console.debug('highlight error (non-critical):', err); }
            
            lastRendered = fullText; 
          } catch(err){
            console.error('flushRender error:', err);
          } 
        };
        const scheduleRender = (immediate=false) => { if (immediate) { if (renderTimer) { clearTimeout(renderTimer); renderTimer=null; } flushRender(); } else { if (renderTimer) clearTimeout(renderTimer); renderTimer = setTimeout(flushRender, 120); } };
        while(true){ const {done,value}=await reader.read(); if(done) break; const chunk=decoder.decode(value,{stream:true}); buffer+=chunk; const lines=buffer.split('\n'); buffer=lines[lines.length-1]; for(let i=0;i<lines.length-1;i++){ const line=lines[i].trim(); if(line.startsWith('data:')){ const data=line.substring(5); if(data.trim()) fullText+=data; } }
          // Only treat a code-fence boundary as complete when followed by a newline
          const immediate = /[.!?][\"')]*\s$/.test(fullText.slice(-4)) || /\n\n/.test(fullText.slice(-2)) || fullText.endsWith('```\n');
          scheduleRender(immediate);
        }
        await flushRender();
        cursor.remove();
      } catch(e) { ab.textContent = 'Error while streaming response.'; }
      askBtn.disabled=false;
    }

    /**
     * FALLBACK-AWARE: Markdown rendering with server-side support and a minimal client-side fallback.
     * Source of truth: com.williamcallahan.javachat.service.MarkdownService (server).
     * If the server endpoint /api/markdown/render fails, we use a BASIC client parser
     * solely to maintain readability (paragraphs, UL/OL, inline code, fenced code).
     * Keep this fallback aligned with server logic:
     *   - preprocessMarkdown()
     *   - applySmartParagraphBreaksImproved()
     *   - fixInlineLists()
     *   - protectCodeBlocks()
     *   - restoreEnrichments()
     *   - render()
     * IMPORTANT: Always fix/extend server behavior first. The fallback is intentionally limited.
     */
         async function renderMarkdown(text){
       text = stripLeadingHeading(text);
       try { 
         const res = await fetch('/api/markdown/render', { 
             method:'POST', 
             headers:{'Content-Type':'application/json'}, 
             body: JSON.stringify({content:text}) 
         }); 
         if(res.ok){ 
             const data=await res.json(); 
             console.log('Server markdown success:', data.html.substring(0, 200));
             return data.html; 
         } else {
             console.error('Server markdown failed with status:', res.status);
         }
       } catch(e){
         console.error('Server markdown error:', e);
       }
       // Safety net: client markdown ONLY
       console.log('Using client fallback for markdown');
       return clientMarkdownFallback(text);
     }
    function stripLeadingHeading(text){
      return text.replace(/^(\s*#{1,6}[^\n]*\n?)+/,'');
    }
    
    /**
     * FALLBACK: Preserve custom enrichment blocks while client-side parsing.
     * Mirrors server placeholders in MarkdownService.preserveEnrichments().
     * Focus fixes on server first; keep placeholder format in sync with server.
     */
    function preserveEnrichments(text){
      return text.replace(/\{\{(hint|reminder|background|example|warning):([\s\S]*?)\}\}/g,(m,t,c)=>`ZZENRICHZ${t}ZSTARTZZZ${c}ZZENRICHZ${t}ZENDZZZ`);
    }
    /**
     * FALLBACK: Restore enrichment placeholders back to {{type:content}}.
     * Mirrors MarkdownService.restoreEnrichments(). Keep in sync with server format.
     */
    function restoreEnrichments(html){
      return html.replace(/ZZENRICHZ(\w+)ZSTARTZZZ([\s\S]*?)ZZENRICHZ\1ZENDZZZ/g,(m,t,c)=>`{{${t}:${c}}}`);
    }
    
    /**
     * FALLBACK: Minimal, safe client markdown renderer.
     * Purpose: readability if /api/markdown/render is unavailable.
     * Scope: paragraphs, UL/OL, inline code, fenced code (escaped). No advanced GFM.
     * Keep behavior broadly aligned with server MarkdownService preprocessing, but do not
     * attempt full parity. Always prioritize server-side rendering for correctness.
     */
    function clientMarkdownFallback(text){
      if(!text) return '';
      const codeBlocks=[];
      // Normalize opening fences with code on same line (shared util)
      if (window.MU) text = MU.normalizeOpeningFences(text);

      let s=text.replace(/```([\w-]+)?\n([\s\S]*?)```/g,(m,lang,code)=>{ const i=codeBlocks.push({lang:(lang||'').trim(),code})-1; return `[[CODE_BLOCK_${i}]]`; });
      s=s.replace(/(:)\s*-\s+(?=\S)/g,'$1\n\n- ');
      s=s.replace(/([.!?])\s+(\d+\.\s+)/g,'$1\n$2');
      s=s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      // Minimal headings (fallback only)
      s=s.replace(/^######\s+(.+)$/gm,'<h6>$1</h6>')
          .replace(/^#####\s+(.+)$/gm,'<h5>$1</h5>')
          .replace(/^####\s+(.+)$/gm,'<h4>$1</h4>')
          .replace(/^###\s+(.+)$/gm,'<h3>$1</h3>')
          .replace(/^##\s+(.+)$/gm,'<h2>$1</h2>')
          .replace(/^#\s+(.+)$/gm,'<h1>$1</h1>');
      s=s.replace(/`([^`]+)`/g,(m,c)=>`<code>${c}</code>`);
      const lines=s.split(/\r?\n/);
      let out='', inUl=false, inOl=false, para='';
      const closeLists=()=>{ if(inUl){ out+='</ul>'; inUl=false;} if(inOl){ out+='</ol>'; inOl=false;} };
      const flushPara=()=>{ if(para.trim()){ out+=`<p>${para.trim()}</p>`;} para=''; };
      for(const raw of lines){
        const line=raw.replace(/\s+$/,'');
        const codePh=line.match(/^\[\[CODE_BLOCK_(\d+)\]\]$/);
        if(codePh){ flushPara(); closeLists(); const idx=parseInt(codePh[1],10); const blk=codeBlocks[idx]||{lang:'',code:''}; const esc=blk.code.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); const cls=blk.lang?` class="language-${blk.lang}"`:''; out+=`<pre><code${cls}>${esc}</code></pre>`; continue; }
        if(/^\s*$/.test(line)){ flushPara(); closeLists(); continue; }
        if(/^-\s+/.test(line)){ flushPara(); if(!inUl){ closeLists(); out+='<ul>'; inUl=true;} out+=`<li>${line.replace(/^-\s+/, '')}</li>`; continue; }
        if(/^\d+\.\s+/.test(line)){ flushPara(); if(!inOl){ closeLists(); out+='<ol>'; inOl=true;} out+=`<li>${line.replace(/^\d+\.\s+/, '')}</li>`; continue; }
        para += (para? ' ' : '') + line;
      }
      flushPara(); closeLists();
      out=out.replace(/\[\[CODE_BLOCK_(\d+)\]\]/g,(m,i)=>{ const idx=parseInt(i,10); const blk=codeBlocks[idx]||{lang:'',code:''}; const esc=blk.code.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); const cls=blk.lang?` class=\"language-${blk.lang}\"`:''; return `<pre><code${cls}>${esc}</code></pre>`; });
      return out;
    }
    function applyEnrichments(text){
      text = text.replace(/\{\{hint:([\s\S]*?)\}\}/g,(m,c)=>{ const ct=c.trim(); return ct ? `<div class="bubble assistant">💡 ${ct}</div>` : ''; });
      text = text.replace(/\{\{reminder:([\s\S]*?)\}\}/g,(m,c)=>{ const ct=c.trim(); return ct ? `<div class="bubble assistant">🔔 ${ct}</div>` : ''; });
      text = text.replace(/\{\{background:([\s\S]*?)\}\}/g,(m,c)=>{ const ct=c.trim(); return ct ? `<div class="bubble assistant">📚 ${ct}</div>` : ''; });
      text = text.replace(/\{\{warning:([\s\S]*?)\}\}/g,(m,c)=>{ const ct=c.trim(); return ct ? `<div class="bubble assistant">⚠️ ${ct}</div>` : ''; });
      text = text.replace(/\[(\d+)\]/g,(m,n)=>`<sup class="inline-citation">[${n}]</sup>`);
      return text;
    }

    function attachCodeCopyButtons(container){ try { const blocks=container.querySelectorAll('pre'); blocks.forEach(pre=>{ if(pre.querySelector('.code-copy-btn')) return; const btn=document.createElement('button'); btn.className='code-copy-btn'; btn.setAttribute('aria-label','Copy code'); btn.title='Copy code'; btn.innerHTML=`<svg width="16" height="16" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`; btn.addEventListener('click',(e)=>{ e.stopPropagation(); const codeEl=pre.querySelector('code'); const text=codeEl?codeEl.innerText:pre.innerText; navigator.clipboard.writeText(text).then(()=>{ btn.classList.add('copied'); const orig=btn.innerHTML; btn.innerHTML=`<svg width="16" height="16" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>`; setTimeout(()=>{ btn.classList.remove('copied'); btn.innerHTML=orig; },1500); }); }); pre.appendChild(btn); }); } catch(_){} }

    /**
     * Safe code block upgrade for guided learning
     * CONSERVATIVE APPROACH: Only process true code blocks, not inline code
     * Preserves existing structure to prevent regression
     */
    function upgradeCodeBlocks(container){
      try {
        // Safety check
        if (!container || typeof container.querySelectorAll !== 'function') {
          console.debug('upgradeCodeBlocks: Invalid container');
          return;
        }
        
        // REMOVED: Multi-line inline code conversion
        // This was causing inline code with newlines to become blocks incorrectly
        // Server-side markdown parser should handle this distinction
        
        // Only ensure proper language classes for syntax highlighting
        const codeBlocks = container.querySelectorAll('pre > code');
        codeBlocks.forEach(code => {
          // Add language class if missing
          if (!code.className || !code.className.includes('language-')) {
            const text = code.textContent || '';
            // Detect Java code patterns
            if (text.includes('public class') || text.includes('import java') || 
                text.includes('public static void') || text.includes('HashMap') ||
                text.includes('String') || text.includes('System.out')) {
              code.className = 'language-java';
            }
          }
        });
        
        // REMOVED: Automatic wrapping in enrichment containers
        // This was causing visual inconsistencies
        // Let the server decide when to wrap code in special containers
        
        console.debug(`upgradeCodeBlocks: Processed ${codeBlocks.length} code blocks`);
        
      } catch (err) {
        // Fail silently to prevent UI breakage
        console.debug('upgradeCodeBlocks: Non-critical error', err);
      }
    }

    // Load the table of contents and the first lesson
    loadTOC().catch(() => setLessonLoading(false));
    
    // Notify parent that page is ready (for top loader)
    try { window.parent.postMessage({ type: 'content-ready' }, '*'); } catch(_){}
  </script>
</body>
</html>
