<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Guided Learning</title>
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png" />
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
  <link rel="icon" type="image/png" href="/favicon-196x196.png" sizes="196x196" />
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="/favicon-128.png" sizes="128x128" />
  <link rel="icon" href="/favicon.ico" />
  <meta name="application-name" content="Java Chat"/>
  <meta name="msapplication-TileColor" content="#FFFFFF" />
  <meta name="msapplication-TileImage" content="/mstile-144x144.png" />
  <meta name="msapplication-square70x70logo" content="/mstile-70x70.png" />
  <meta name="msapplication-square150x150logo" content="/mstile-150x150.png" />
  <meta name="msapplication-wide310x150logo" content="/mstile-310x150.png" />
  <meta name="msapplication-square310x310logo" content="/mstile-310x310.png" />
  
  <!-- Mobile-specific meta tags -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="format-detection" content="telephone=no" />
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <link href="/css/app.css?v=mobile-responsive" rel="stylesheet" />
</head>
<body class="guided-learning">
  <div class="container">
    <div class="lesson-selector">
        <button id="prevBtn" aria-label="Previous lesson">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
        </button>
        <select id="lessonSelect" aria-label="Lesson selector"></select>
        <button id="nextBtn" aria-label="Next lesson">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
        </button>
    </div>

    <!-- Main content area -->
    <div id="lesson-container">
        <div id="lessonSummary" class="muted" style="margin-bottom: var(--space-4);"></div>

        <div id="lessonSkeleton" class="lesson-loading hidden" aria-hidden="true">
            <div class="loading-dots">
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
            </div>
            <p class="loading-text">Loading lesson content...</p>
        </div>

        <div id="lessonContentWrapper">
            <div id="citations" class="citations-row" aria-label="Citations"></div>
            <div id="lessonContent" class="lesson-content" aria-live="polite"></div>
            <div id="enrichment" style="margin-top: 12px"></div>
        </div>
    </div>

    <div id="guidedChat">
        <div id="chatArea" aria-live="polite" aria-label="Guided chat messages"></div>
        
        <button class="export-chat-btn" onclick="copyGuidedChat()" aria-label="Copy entire chat" title="Copy entire chat">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2 2v1"></path>
            </svg>
        </button>
        
        <div class="input-area">
            <div class="input-row">
                <div class="input-wrapper">
                    <input id="q" class="input" placeholder="Ask a question about this lesson" onkeypress="if(event.key==='Enter') ask()"/>
                    <button id="askBtn" class="btn" onclick="ask()" aria-label="Send question">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script>
    let toc = [];
    let currentIndex = 0;
    let glossary = [];
    let currentLoadId = 0;
    let activeControllers = [];

    function cancelActiveControllers(){
      activeControllers.forEach(c => { try { c.abort(); } catch(_){} });
      activeControllers = [];
    }

    function setLessonLoading(isLoading){
      const sk = document.getElementById('lessonSkeleton');
      const prev = document.getElementById('prevBtn');
      const next = document.getElementById('nextBtn');
      const ask = document.getElementById('askBtn');
      sk.classList.toggle('hidden', !isLoading);
      prev.disabled = isLoading || prev.disabled;
      next.disabled = isLoading || next.disabled;
      ask.disabled = isLoading || ask.disabled;
    }

    async function loadTOC() {
      setLessonLoading(true);
      const res = await fetch('/api/guided/toc');
      toc = await res.json();
      // Fetch tooltips glossary once
      try { const gres = await fetch('/api/tooltips/list'); if (gres.ok) glossary = await gres.json(); } catch(_){}
      const sel = document.getElementById('lessonSelect');
      sel.innerHTML = '';
      toc.forEach((l, i) => {
        const opt = document.createElement('option');
        opt.value = l.slug; opt.textContent = l.title; sel.appendChild(opt);
      });
      sel.onchange = () => {
        currentIndex = Math.max(0, toc.findIndex(l => l.slug === sel.value));
        loadLesson(toc[currentIndex].slug);
      };
      if (toc.length > 0) {
        currentIndex = 0;
        sel.value = toc[0].slug;
        await loadLesson(toc[0].slug);
      }
      document.getElementById('prevBtn').onclick = prevLesson;
      document.getElementById('nextBtn').onclick = nextLesson;
      updateNavButtons();
      setLessonLoading(false);
    }

    function prevLesson() { if (currentIndex > 0) { currentIndex--; selectByIndex(); } }
    function nextLesson() { if (currentIndex < toc.length - 1) { currentIndex++; selectByIndex(); } }
    function selectByIndex() { const sel = document.getElementById('lessonSelect'); sel.value = toc[currentIndex].slug; loadLesson(toc[currentIndex].slug); updateNavButtons(); }
    function updateNavButtons() { document.getElementById('prevBtn').disabled = currentIndex === 0; document.getElementById('nextBtn').disabled = currentIndex === toc.length - 1; }

    async function loadLesson(slug) {
      // Cancel any in-flight fetch/streams and clear UI immediately
      cancelActiveControllers();
      const wrap = document.getElementById('citations');
      const content = document.getElementById('lessonContent');
      const enrich = document.getElementById('enrichment');
      const chatArea = document.getElementById('chatArea');
      wrap.innerHTML = '';
      content.innerHTML = '';
      enrich.innerHTML = '';
      chatArea.innerHTML = '';
      setLessonLoading(true);
      currentLoadId++;
      const loadId = currentLoadId;
      try {
        const res = await fetch('/api/guided/lesson?slug=' + encodeURIComponent(slug));
        const lesson = await res.json();
        document.getElementById('lessonSummary').textContent = lesson.summary || '';
        await Promise.all([
          loadCitations(slug, loadId),
          loadLessonContent(slug, loadId),
          loadEnrichment(slug, loadId)
        ]);
      } finally {
        setLessonLoading(false);
      }
    }

    async function loadLessonContent(slug, loadId){
      const el = document.getElementById('lessonContent');
      el.innerHTML = '';
      try {
        const controller = new AbortController();
        activeControllers.push(controller);
        const response = await fetch('/api/guided/content/stream?slug=' + encodeURIComponent(slug), { signal: controller.signal });
        if (!response.ok) { el.textContent = 'Failed to load lesson content.'; return; }
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullText = '';
        let buffer = '';
        let firstChunkShown = false;
        // Debounced rendering for smoother lesson updates
        let renderTimer = null; let lastRendered = '';
        // Track if we're in a list or code block
        let inList = false;
        let inCode = false;
        const flushRender = async () => { 
          try { 
            if (loadId !== currentLoadId) return; 
            if (fullText === lastRendered) return; 
            const html = await renderMarkdown(fullText); 
            el.innerHTML = html; 
            
            // Safe function calls with error handling
            try {
              upgradeCodeBlocks(el);
            } catch (err) {
              console.debug('upgradeCodeBlocks error (non-critical):', err);
            }
            
            try { (window.MU?MU.attachCodeCopyButtons:()=>{})(el); } catch (err) { console.debug('attachCodeCopyButtons error (non-critical):', err); }
            try { (window.MU?MU.safeHighlightUnder:Prism.highlightAllUnder)(el); } catch (err) { console.debug('highlight error (non-critical):', err); }
            
            try {
              applyGlossaryTooltips(el);
            } catch (err) {
              console.debug('Glossary tooltips error (non-critical):', err);
            }
            
            lastRendered = fullText; 
          } catch(err){
            console.error('flushRender error:', err);
          } 
        };
        const scheduleRender = (immediate=false) => { if (immediate) { if (renderTimer) { clearTimeout(renderTimer); renderTimer=null; } flushRender(); } else { if (renderTimer) clearTimeout(renderTimer); renderTimer = setTimeout(flushRender, 120); } };
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          buffer += chunk;
          const lines = buffer.split('\n');
          buffer = lines[lines.length - 1];
          for (let i = 0; i < lines.length - 1; i++) {
            let line = lines[i];
            if (line.endsWith('\r')) line = line.slice(0, -1);
            if (line.startsWith('data:')) {
              const data = line.slice(5);
              // Prevent word concatenation when deltas are alphanumeric
              const prev = acc ? acc.charAt(acc.length - 1) : '';
              if (prev && /[A-Za-z0-9]/.test(prev) && /^[A-Za-z0-9]/.test(data)) {
                acc += ' ';
              }
              // STEP 1: Check for code block boundaries FIRST
              if (data.includes('```')) {
                const beforeFence = data.indexOf('```');
                if (beforeFence > 0) {
                  fullText += data.substring(0, beforeFence);
                }
                inCode = !inCode;
                fullText += data.substring(beforeFence) + '\n';
                inList = false;
                continue;
              }
              
              // STEP 2: If in code block, preserve exactly
              if (inCode) {
                fullText += data + '\n';
                continue;
              }
              
              // STEP 3: Check for list markers
              const startsWithListMarker = /^\s*(?:\d+[.)]|[a-zA-Z][.)]|[-*+])\s+/.test(data);
              
              // Handle empty lines - they end lists
              if (!data) {
                if (inList) {
                  fullText += '\n';
                  inList = false;
                } else {
                  fullText += '\n';
                }
                continue;
              }
              
              // Check for split list marker ("1." in one chunk, text in next)
              const tail = fullText.slice(-10).trim();
              const endsWithListMarker = /(?:\d+[.)]|[a-zA-Z][.)]|[-*+])\s*$/.test(tail);
              if (endsWithListMarker && /^\S/.test(data)) {
                // This is continuation of a list marker - just append with space
                fullText += ' ' + data;
                inList = true;
                continue;
              }
              
              // New list item starting
              if (startsWithListMarker) {
                if (fullText.length > 0 && !fullText.endsWith('\n')) {
                  // Add newline before new list item
                  fullText += inList ? '\n' : '\n\n';
                }
                fullText += data;
                inList = true;
                continue;
              }
              
              // STEP 4: Are we in a list?
              if (inList) {
                // Continuation of current list item - just add space if needed
                const needsSpace = fullText.length > 0 && 
                                  !fullText.endsWith(' ') && 
                                  !fullText.endsWith('\n') &&
                                  !data.startsWith(' ');
                fullText += needsSpace ? ' ' + data : data;
                continue;
              }
              
              // STEP 5: Regular paragraph (not in list, not in code)
              if (fullText.length > 0) {
                // Need double newline before new paragraph
                if (!fullText.endsWith('\n\n')) {
                  if (fullText.endsWith('\n')) {
                    fullText += '\n';
                  } else {
                    fullText += '\n\n';
                  }
                }
              }
              fullText += data;
            }
          }
          // If user switched lessons, drop work
          if (loadId !== currentLoadId) return;
          // Only treat a code-fence boundary as complete when followed by a newline
          const immediate = window.MU ? MU.shouldImmediateFlush(fullText) : (/[.!?][\"')]*\s$/.test(fullText.slice(-4)) || /\n\n/.test(fullText.slice(-2)) || fullText.endsWith('```\n'));
          scheduleRender(immediate);
          if (!firstChunkShown) {
            firstChunkShown = true;
            setLessonLoading(false);
            // Inform parent to hide top loader immediately
            try { window.parent.postMessage({ type: 'content-started' }, '*'); } catch(_){}
          }
        }
        await flushRender();
      } catch (_) {
        el.textContent = 'Error streaming lesson content.';
      }
    }

    function applyGlossaryTooltips(container){
      if (!glossary || glossary.length === 0) return;
      const maxTooltips = 5; let applied = 0;
      const terms = glossary.map(g => ({ term: g.term || g.term, def: g.definition || g.definition, link: g.link || g.link }));
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
      const nodes = [];
      while (walker.nextNode()) nodes.push(walker.currentNode);
      for (const node of nodes) {
        if (applied >= maxTooltips) break;
        const parent = node.parentElement;
        if (!parent) continue;
        const tag = parent.tagName.toLowerCase();
        if (tag === 'code' || tag === 'pre' || tag === 'a') continue;
        let text = node.nodeValue;
        for (const t of terms) {
          if (applied >= maxTooltips) break;
          const re = new RegExp('\\b' + escapeRegExp(t.term) + '\\b','i');
          if (re.test(text)) {
            const span = document.createElement('span');
            const replaced = text.replace(re, (m)=>`<abbr title="${escapeHtml(t.def)}">${m}</abbr>`);
            span.innerHTML = replaced;
            parent.replaceChild(span, node);
            applied++;
            break;
          }
        }
      }
    }
    function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
    function escapeHtml(s){
      const d = document.createElement('div'); d.textContent = s; return d.innerHTML;
    }

    async function loadCitations(slug, loadId) {
      const wrap = document.getElementById('citations'); wrap.innerHTML = '';
      const controller = new AbortController();
      activeControllers.push(controller);
      const res = await fetch('/api/guided/citations?slug=' + encodeURIComponent(slug), { signal: controller.signal });
      const citations = await res.json();
      if (loadId !== currentLoadId) return;
      
      // Early return if no citations - prevents empty styled containers (matches chat.html behavior)
      if (!citations || citations.length === 0) return;
      
      // Use shared citation rendering function with DOM parity (append the row)
      if (typeof MU !== 'undefined' && MU.createCitationsRow) {
        const citationsRow = MU.createCitationsRow(citations, 5);
        wrap.appendChild(citationsRow);
      } else {
        // Fallback: create a row container and pills (parity preserved)
        console.warn('MU.createCitationsRow not available, using fallback');
        const row = document.createElement('div');
        row.className = 'citations-row';
        citations.slice(0, 5).forEach((c, i) => {
          const a = document.createElement(c.url ? 'a' : 'div');
          a.className = 'citation-pill';
          if (c.url) { a.href = c.url; a.target = '_blank'; a.rel = 'noopener noreferrer'; }
          const fallbackLabel = (c.title || 'Source').replace(/::/g, '|');
          a.textContent = `${i + 1}. ${fallbackLabel}`;
          row.appendChild(a);
        });
        wrap.appendChild(row);
      }
    }

    async function loadEnrichment(slug, loadId) {
      const div = document.getElementById('enrichment'); div.innerHTML = '';
      const controller = new AbortController();
      activeControllers.push(controller);
      const res = await fetch('/api/guided/enrich?slug=' + encodeURIComponent(slug), { signal: controller.signal });
      if (!res.ok) return; const enrichment = await res.json();
      if (loadId !== currentLoadId) return;

      // Check for existing enrichments from inline markdown to avoid duplicates
      const existingTypes = new Set();
      document.querySelectorAll('[data-enrichment-type]').forEach(el => {
        existingTypes.add(el.getAttribute('data-enrichment-type'));
      });

      // Use shared enrichment block generator for DRY parity
      const createEnrichmentBlock = (type, title, _svgPath, items) => {
        // Only create if this type doesn't already exist
        if (!existingTypes.has(type) && items && items.length > 0) {
          try { div.appendChild(MU.createEnrichmentBlock(type, title, items)); } catch (_) {}
        }
      };

      createEnrichmentBlock(
        'hint', 'Helpful Hints',
        '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>',
        enrichment.hints
      );
      createEnrichmentBlock(
        'background', 'Background Context',
        '<path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/>',
        enrichment.background
      );
      createEnrichmentBlock(
        'reminder', 'Important Reminders',
        '<path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"/>',
        enrichment.reminders
      );
    }

    async function ask() {
      const input = document.getElementById('q'); const q = input.value.trim(); if (!q) return;
      const lesson = toc[currentIndex]; const slug = lesson.slug;
      const chatArea = document.getElementById('chatArea'); const askBtn = document.getElementById('askBtn');
      // user bubble
      const ub = document.createElement('div'); ub.className = 'bubble user'; ub.textContent = q; chatArea.appendChild(ub);
      
      
      input.value=''; askBtn.disabled=true;
      // assistant bubble
      const ab = document.createElement('div'); ab.className = 'bubble assistant'; 
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'loading-dots';
      loadingDiv.innerHTML = `
          <span class="loading-dot"></span>
          <span class="loading-dot"></span>
          <span class="loading-dot"></span>
      `;
      ab.appendChild(loadingDiv);
      chatArea.appendChild(ab);
      const content = document.createElement('div'); content.className = 'streaming-text';
      try {
        const response = await fetch('/api/guided/stream', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ sessionId: 'guided:'+slug, slug, latest: q }) });
        if (!response.ok) throw new Error('HTTP '+response.status);
        // Keep loading animation until first content chunk arrives
        const cursor = document.createElement('span'); 
        cursor.className = 'typing-cursor'; 
        
        const reader = response.body.getReader(); const decoder = new TextDecoder(); let fullText=''; let buffer='';
        let renderTimer=null; let lastRendered=''; let firstChunk=false;
        // Track if we're in a list or code block
        let inList = false;
        let inCode = false;
        const flushRender = async () => { 
          try { 
            if (fullText === lastRendered) return; 
            
            // Remove loading animation on first content chunk
            if (!firstChunk && fullText.trim()) {
              firstChunk = true;
              loadingDiv.remove();
              ab.appendChild(content);
              content.appendChild(cursor);
            }
            
            const html = await renderMarkdown(fullText); 
            content.innerHTML = html; 
            
            // Safe function calls with error handling
            try {
              upgradeCodeBlocks(content);
            } catch (err) {
              console.debug('upgradeCodeBlocks error (non-critical):', err);
            }
            
            try {
              attachCodeCopyButtons(content);
            } catch (err) {
              console.debug('attachCodeCopyButtons error (non-critical):', err);
            }
            
            // Re-add cursor after content updates (only if content wrapper is in DOM)
            if (firstChunk) {
              content.appendChild(cursor);
            }
            try { (window.MU?MU.safeHighlightUnder:Prism.highlightAllUnder)(content); } catch (err) { console.debug('highlight error (non-critical):', err); }
            
            lastRendered = fullText; 
          } catch(err){
            console.error('flushRender error:', err);
          } 
        };
        const scheduleRender = (immediate=false) => { if (immediate) { if (renderTimer) { clearTimeout(renderTimer); renderTimer=null; } flushRender(); } else { if (renderTimer) clearTimeout(renderTimer); renderTimer = setTimeout(flushRender, 120); } };
        while(true){ 
          const {done,value}=await reader.read(); 
          if(done) break; 
          const chunk=decoder.decode(value,{stream:true}); 
          buffer+=chunk; 
          const lines=buffer.split('\n'); 
          buffer=lines[lines.length-1]; 
          for(let i=0;i<lines.length-1;i++){ 
            let line=lines[i];
            if(line.endsWith('\r')) line=line.slice(0,-1);
            // Skip SSE comments (e.g., ": keepalive")
            if (line.startsWith(':')) { continue; }
            if(line.startsWith('data:')){
              const data=line.substring(5);
              
              // Check for code block boundaries FIRST
              if(data.includes('```')) {
                // Code fence detected - toggle state
                const beforeFence = data.indexOf('```');
                if(beforeFence > 0) {
                  // Content before the fence
                  fullText += data.substring(0, beforeFence);
                }
                inCode = !inCode;
                // Add the fence and everything after
                fullText += data.substring(beforeFence) + '\n';
                inList = false; // Code blocks reset list context
                continue;
              }
              
              // Inside code block - preserve EXACTLY as received, just add protocol newline
              if(inCode) {
                fullText += data + '\n';
                continue;
              }
              
              // Empty data line outside code - preserve it
              if(!data) {
                fullText += '\n';
                continue;
              }
              
              // Check if this line starts a list item
              const startsWithListMarker = /^\s*(?:\d+[.)]|[a-zA-Z][.)]|[-*+])\s+/.test(data);
              
              // Check if previous content ends with a list marker (split marker case)
              const tail = fullText.slice(-10).trim();
              const endsWithListMarker = /(?:\d+[.)]|[a-zA-Z][.)]|[-*+])\s*$/.test(tail);
              
              if(endsWithListMarker && /^\S/.test(data)) {
                // List marker at end of previous chunk, content at start of this - keep together
                fullText += data;
                inList = true;
              } else if(startsWithListMarker) {
                // New list item starting
                if(fullText.length > 0 && !fullText.endsWith('\n')) {
                  // Need a newline before list item
                  fullText += inList ? '\n' : '\n\n'; // Single newline if continuing list, double if not
                }
                fullText += data;
                inList = true;
              } else if(inList) {
                // Continuing within a list item
                fullText += data + '\n';
                // Check if this looks like end of list (e.g., ends with period)
                if(/[.!?]\s*$/.test(data)) {
                  inList = false;
                }
              } else {
                // Regular paragraph text - use double newline for separation
                if(fullText.length > 0) {
                  // Ensure proper paragraph separation
                  if(!fullText.endsWith('\n\n') && !fullText.endsWith('\n')) {
                    fullText += '\n\n';
                  } else if(fullText.endsWith('\n') && !fullText.endsWith('\n\n')) {
                    fullText += '\n';
                  }
                }
                fullText += data;
              }
            }
          }
          // Only treat a code-fence boundary as complete when followed by a newline
          // Safety: strip any leaked SSE tokens that made it into payload text
          if (fullText.indexOf('data:') !== -1) {
            fullText = fullText.replace(/(^|\n)\s*data:\s*/g, '$1');
            fullText = fullText.replace(/([A-Za-z0-9])data:\s*/g, '$1');
          }
          const immediate = /[.!?][\"')]*\s$/.test(fullText.slice(-4)) || /\n\n/.test(fullText.slice(-2)) || fullText.endsWith('```\n');
          scheduleRender(immediate);
        }
        await flushRender();
        cursor.remove();
      } catch(e) { ab.textContent = 'Error while streaming response.'; }
      askBtn.disabled=false;
    }

    /**
     * ENHANCED: AST-based markdown rendering with structured data support.
     * Uses the new UnifiedMarkdownService for AGENTS.md compliant processing.
     * Falls back to legacy processing if needed for backward compatibility.
     */
         async function renderMarkdown(text, useStructured = true){
      text = stripLeadingHeading(text);
      const preserved = preserveEnrichments(text);
      
      // Try the new structured endpoint first for better processing
      if (useStructured) {
          try {
              const res = await fetch('/api/markdown/render/structured', { 
                  method:'POST', 
                  headers:{'Content-Type':'application/json'}, 
                  body: JSON.stringify({content: preserved}) 
              }); 
              if(res.ok){ 
                  const data=await res.json(); 
                  console.debug('AST-based processing (guided):', {
                      citations: data.citations?.length || 0,
                      enrichments: data.enrichments?.length || 0,
                      processingTime: data.processingTimeMs,
                      isClean: data.isClean
                  });
                  const restored = restoreEnrichments(data.html);
                  return (window.MU && MU.applyInlineEnrichments) ? MU.applyInlineEnrichments(restored) : restored; 
              }
              console.warn('Structured markdown failed, falling back to legacy:', res.status);
          } catch(e){
              console.warn('Structured markdown error, falling back to legacy:', e);
          }
      }
      
      // Fallback to legacy endpoint (still uses new processStructured internally)
      try { 
        const res = await fetch('/api/markdown/render', { 
            method:'POST', 
            headers:{'Content-Type':'application/json'}, 
            body: JSON.stringify({content: preserved}) 
        }); 
        if(res.ok){ 
            const data=await res.json(); 
            const restored = restoreEnrichments(data.html);
            return (window.MU && MU.applyInlineEnrichments) ? MU.applyInlineEnrichments(restored) : restored; 
        } else {
            console.error('Server markdown failed with status:', res.status);
        }
      } catch(e){
        console.error('Server markdown error:', e);
      }
      // Safety net: client markdown ONLY
      console.log('Using client fallback for markdown');
     let out = clientMarkdownFallback(preserved);
     try { if (window.MU && MU.hoistMarkerOnlyLines) out = MU.hoistMarkerOnlyLines(out); } catch {}
     const restored = restoreEnrichments(out);
     return (window.MU && MU.applyInlineEnrichments) ? MU.applyInlineEnrichments(restored) : restored;
     }
    function stripLeadingHeading(text){
      return text.replace(/^(\s*#{1,6}[^\n]*\n?)+/,'');
    }
    
    /**
     * FALLBACK: Preserve custom enrichment blocks while client-side parsing.
     * Mirrors server placeholders in MarkdownService.preserveEnrichments().
     * Focus fixes on server first; keep placeholder format in sync with server.
     */
    function preserveEnrichments(text){
      return text.replace(/\{\{(hint|reminder|background|example|warning):([\s\S]*?)\}\}/g,(m,t,c)=>`ZZENRICHZ${t}ZSTARTZZZ${c}ZZENRICHZ${t}ZENDZZZ`);
    }
    /**
     * FALLBACK: Restore enrichment placeholders back to {{type:content}}.
     * Mirrors MarkdownService.restoreEnrichments(). Keep in sync with server format.
     */
    function restoreEnrichments(html){
      return html.replace(/ZZENRICHZ(\w+)ZSTARTZZZ([\s\S]*?)ZZENRICHZ\1ZENDZZZ/g,(m,t,c)=>`{{${t}:${c}}}`);
    }
    
    /**
     * FALLBACK: Minimal, safe client markdown renderer.
     * Purpose: readability if /api/markdown/render is unavailable.
     * Scope: paragraphs, UL/OL, inline code, fenced code (escaped). No advanced GFM.
     * Keep behavior broadly aligned with server MarkdownService preprocessing, but do not
     * attempt full parity. Always prioritize server-side rendering for correctness.
     */
    function clientMarkdownFallback(text){
      if(!text) return '';
      const codeBlocks=[];
      // Normalize opening fences with code on same line (shared util)
      if (window.MU) { 
        text = MU.normalizeOpeningFences(text); 
        text = MU.promoteLikelyJavaBlocks(text);
      }

      let s=text.replace(/```([\w-]+)?\n?([\s\S]*?)\n?```/g,(m,lang,code)=>{ const i=codeBlocks.push({lang:(lang||'').trim(),code:code.trim()})-1; return `\n\n[[CODE_BLOCK_${i}]]\n\n`; });
      // Normalize lists safely now that code is protected
      try { if (window.MU) { s = MU.normalizeInlineOrderedLists(s); s = MU.hoistMarkerOnlyLines(s); } } catch {}
      s=s.replace(/(:)\s*[-*+•→▸◆□▪]\s+(?=\S)/g,'$1\n\n- ');
      s=s.replace(/([.!?])\s+(\d+\.\s+)/g,'$1\n\n$2');
      s=s.replace(/([.!?])\s+([-*+•→▸◆□▪]\s+)/g,'$1\n\n$2');
      s=s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      // Minimal emphasis handling after HTML escape and code protection
      s = s.replace(/\*\*\s+([\s\S]*?)\s+\*\*/g, '**$1**');
      s = s.replace(/\*\*([^*][\s\S]*?)\*\*/g, '<strong>$1</strong>');
      s = s.replace(/(^|[^*])\*\s*([^*][^\n]*?)\s*\*(?!\*)/g, (m,pfx,body)=> `${pfx}<em>${body}</em>`);
      // Minimal headings (fallback only)
      s=s.replace(/^######\s+(.+)$/gm,'<h6>$1</h6>')
          .replace(/^#####\s+(.+)$/gm,'<h5>$1</h5>')
          .replace(/^####\s+(.+)$/gm,'<h4>$1</h4>')
          .replace(/^###\s+(.+)$/gm,'<h3>$1</h3>')
          .replace(/^##\s+(.+)$/gm,'<h2>$1</h2>')
          .replace(/^#\s+(.+)$/gm,'<h1>$1</h1>');
      s=s.replace(/`([^`]+)`/g,(m,c)=>`<code>${c}</code>`);
      const lines=s.split(/\r?\n/);
      let out='', inUl=false, inOl=false, para='';
      const closeLists=()=>{ if(inUl){ out+='</ul>'; inUl=false;} if(inOl){ out+='</ol>'; inOl=false;} };
      const flushPara=()=>{ if(para.trim()){ out+=`<p>${para.trim()}</p>`;} para=''; };
      for(const raw of lines){
        const line=raw.replace(/\s+$/,'');
        const codePh=line.match(/^\[\[CODE_BLOCK_(\d+)\]\]$/);
        if(codePh){ flushPara(); closeLists(); const idx=parseInt(codePh[1],10); const blk=codeBlocks[idx]||{lang:'',code:''}; const esc=blk.code.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); const cls=blk.lang?` class="language-${blk.lang}"`:''; out+=`<pre><code${cls}>${esc}</code></pre>`; continue; }
        if(/^\s*$/.test(line)){ flushPara(); closeLists(); continue; }
        if(/^[-*+•→▸◆□▪]\s+/.test(line)){ flushPara(); if(!inUl){ closeLists(); out+='<ul>'; inUl=true;} out+=`<li>${line.replace(/^[-*+•→▸◆□▪]\s+/, '')}</li>`; continue; }
        if(/^\d+\.\s+/.test(line)){ flushPara(); if(!inOl){ closeLists(); out+='<ol>'; inOl=true;} out+=`<li>${line.replace(/^\d+\.\s+/, '')}</li>`; continue; }
        para += (para? ' ' : '') + line;
      }
      flushPara(); closeLists();
      out=out.replace(/\[\[CODE_BLOCK_(\d+)\]\]/g,(m,i)=>{ const idx=parseInt(i,10); const blk=codeBlocks[idx]||{lang:'',code:''}; const esc=blk.code.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); const cls=blk.lang?` class=\"language-${blk.lang}\"`:''; return `<pre><code${cls}>${esc}</code></pre>`; });
      return out;
    }
    // applyEnrichments() removed: unified MU.applyInlineEnrichments handles cards.

    function attachCodeCopyButtons(container){ try { const blocks=container.querySelectorAll('pre'); blocks.forEach(pre=>{ if(pre.querySelector('.code-copy-btn')) return; const btn=document.createElement('button'); btn.className='code-copy-btn'; btn.setAttribute('aria-label','Copy code'); btn.title='Copy code'; btn.innerHTML=`<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`; btn.addEventListener('click',(e)=>{ e.stopPropagation(); const codeEl=pre.querySelector('code'); const text=codeEl?codeEl.innerText:pre.innerText; navigator.clipboard.writeText(text).then(()=>{ btn.classList.add('copied'); const orig=btn.innerHTML; btn.innerHTML=`<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>`; setTimeout(()=>{ btn.classList.remove('copied'); btn.innerHTML=orig; },1500); }); }); pre.appendChild(btn); }); } catch(_){} }

    /**
     * Safe code block upgrade for guided learning
     * CONSERVATIVE APPROACH: Only process true code blocks, not inline code
     * Preserves existing structure to prevent regression
     */
    function upgradeCodeBlocks(container){
      try {
        // Safety check
        if (!container || typeof container.querySelectorAll !== 'function') {
          console.debug('upgradeCodeBlocks: Invalid container');
          return;
        }
        
        // REMOVED: Multi-line inline code conversion
        // This was causing inline code with newlines to become blocks incorrectly
        // Server-side markdown parser should handle this distinction
        
        // Only ensure proper language classes for syntax highlighting
        const codeBlocks = container.querySelectorAll('pre > code');
        codeBlocks.forEach(code => {
          // Add language class if missing
          if (!code.className || !code.className.includes('language-')) {
            const text = code.textContent || '';
            // Detect Java code patterns
            if (text.includes('public class') || text.includes('import java') || 
                text.includes('public static void') || text.includes('HashMap') ||
                text.includes('String') || text.includes('System.out')) {
              code.className = 'language-java';
            }
          }
        });
        
        // REMOVED: Automatic wrapping in enrichment containers
        // This was causing visual inconsistencies
        // Let the server decide when to wrap code in special containers
        
        console.debug(`upgradeCodeBlocks: Processed ${codeBlocks.length} code blocks`);
        
      } catch (err) {
        // Fail silently to prevent UI breakage
        console.debug('upgradeCodeBlocks: Non-critical error', err);
      }
    }

    async function copyGuidedChat() {
      try {
        const lesson = toc[currentIndex];
        const slug = lesson ? lesson.slug : 'unknown';
        const sessionId = 'guided:' + slug;
        
        const res = await fetch('/api/chat/export/session?sessionId=' + encodeURIComponent(sessionId));
        const txt = await res.text();
        await navigator.clipboard.writeText(txt);
        
        const btn = document.querySelector('.export-chat-btn');
        if (btn) {
          btn.style.background = 'var(--accent-success)';
          btn.style.color = 'white';
          setTimeout(() => {
            btn.style.background = '';
            btn.style.color = '';
          }, 2000);
        }
        
        // Show toast notification (if available)
        if (typeof showToast === 'function') {
          showToast('Chat session exported to clipboard!');
        }
      } catch (error) {
        console.error('Failed to export guided chat:', error);
        if (typeof showToast === 'function') {
          showToast('Failed to export', 'error');
        }
      }
    }

    // Mobile-specific optimizations
    function initMobileOptimizations() {
        // Prevent iOS Safari from pausing timers when scrolling
        if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
            document.addEventListener('scroll', function() {
                // Keep timers active during scroll
            }, { passive: true });
        }
        
        // Improve touch responsiveness
        document.addEventListener('touchstart', function() {}, { passive: true });
        
        // Handle orientation change for guided learning
        window.addEventListener('orientationchange', function() {
            setTimeout(() => {
                // Ensure lesson content is properly positioned after rotation
                const lessonContent = document.getElementById('lesson-content');
                const chatArea = document.getElementById('chatArea');
                if (lessonContent) {
                    lessonContent.scrollTop = 0; // Reset to top for better UX
                }
                if (chatArea) {
                    chatArea.scrollTop = chatArea.scrollHeight; // Keep chat at bottom
                }
            }, 100);
        });
    }

    // Initialize mobile optimizations
    initMobileOptimizations();
    
    // Load the table of contents and the first lesson
    loadTOC().catch(() => setLessonLoading(false));
    
    // Notify parent that page is ready (for top loader)
    try { window.parent.postMessage({ type: 'content-ready' }, '*'); } catch(_){}
  </script>
</body>
</html>
