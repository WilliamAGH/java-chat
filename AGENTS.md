---
description: "Java Chat - AI-powered Java learning with streaming responses, citations, and knowledge augmentation"
alwaysApply: true
---

- GT1 All git commands require elevated permissions; never run without escalation.
- GT2 Never remove `.git/index.lock` automatically; stop and ask the user.
- GT3 No destructive git commands (`git restore`, `git reset`, force checkout) unless explicitly ordered.
- GT4 Do not skip commit signing or hooks; no `--no-verify`.
- GT5 No `Co-authored-by` or AI attribution in commits; no `--amend` or history-altering without instruction.
- GT6 Do not stage/restore/rewrite files you did not modify; surface unexpected diffs and wait.
- FS1 Before any new file: search exhaustively for existing logic; if found, reuse/extend; if not, create in canonical locations.
- FS2 No `Map<String, Object>`, raw types, unchecked casts, `@SuppressWarnings`, `@ts-ignore`, or `eslint-disable` in production.
- FS3 If a cast is unavoidable, guard with explicit conversions (e.g., `Number::intValue`) instead of suppressing.
- FS4 Single-responsibility methods; no dead code; no empty try/catch that swallows exceptions.
- FS5 Domain has zero framework imports; dependencies point inward.
- FS6 Convention over configuration: prefer Spring Boot defaults and existing utilities.
- FS7 Ban map/bloated tooling: no `toMap()/fromMap()`, no stringly helpers, no redundant adapters.
- FS8 No generic utilities: reject `*Utils/*Helper/*Common`; banned: `BaseMapper<T>`, `GenericRepository<T,ID>`, `SharedUtils`.
- FS9 Large files (>500 LOC): extract only pieces you touch into clean-architecture roots; avoid broad refactors.
- FS10 Domain value types: identifiers, amounts, slugs wrap in records with constructor validation; never raw primitives across API boundaries.
- FS11 Never use `@SuppressWarnings` to resolve lint issues; fix the code or refactor structure to comply with rules.
- MO1 Monolith = >500 LOC or multi-concern catch-all (`*Utils/*Helper/*Common`).
- MO2 New functionality starts in new files in canonical roots; never add code to monoliths.
- MO3 Shrink on touch: when editing monoliths, extract at least one seam and net-decrease file size; if unsafe, stop and ask.
- ND1 No generic identifiers; names must be domain-specific and intent-revealing.
- ND2 Banned names: `data`, `info`, `value`, `values`, `item`, `items`, `obj`, `object`, `thing`, `result`, `results`, `temp`, `tmp`, `misc`, `foo`, `bar`, `a`, `b`, `x`, `y`, `i`, `j`, `k`.
- ND3 When legacy code uses generic names, rename in the same edit; never introduce new generic names.
- AB1 No anemic wrappers: do not add classes that only forward calls without domain value.
- AB2 Abstractions must earn reuse: extend existing code first; only add new type/helper when it removes real duplication.
- AB3 Keep behavior close to objects: invariants live in domain model/services, not mappers or helpers.
- AB4 Delete unused code instead of keeping it "just in case."
- CS1 Primitive obsession: wrap IDs/amounts/business values in domain types when they carry invariants.
- CS2 Data clumps: when 3+ parameters travel together, extract into a record (`DateRange`, `PageSpec`, `SearchCriteria`).
- CS3 Long parameter lists: >4 parameters use parameter object or builder; never add 5th positional argument.
- CS4 Feature envy: if method uses another object's data more than its own, move it there.
- CS5 Switch/if-else on type: replace with polymorphism when branches >3 or recur.
- CS6 Temporal coupling: enforce call order via state machine, builder, or combined API; never rely on caller discipline.
- CS7 Magic literals: no inline numbers (except 0, 1, -1) or strings; define named constants with intent-revealing names.
- CS8 Comment deodorant: if comment explains what, refactor until self-documenting; comments explain why only.
- RC1 No fallback code that masks issues; no silent degradation (catch-and-log-empty, return-null on failure).
- RC2 Investigate, understand, fix; no workarounds; let errors surface.
- RC3 One definition only: no alternate implementations behind flags; dev-only logging allowed, remove before shipping.
- RC4 No shims/workarounds ever; never introduce adapters, wrappers, type casts, or bridge code to silence errors; fix at source or halt.
- RC5 Use typed exception handling patterns; propagate meaningful errors, never swallow silently.
- NO1 Public methods never return null; singletons use `Optional<T>`; collections return empty, never null.
- NO2 Domain models enforce invariants; avoid nullable fields unless business-optional and documented.
- NO3 Prefer empty collections: return `List.of()`, `Set.of()`, `Map.of()` instead of null.
- NO4 Optional parameters prohibited in business logic: accept nullable `T`, check internally; call sites unwrap with `.orElse(null)`.
- NO5 Use `Optional.map/flatMap/orElseThrow`; avoid `isPresent()/get()` chains.
- AR1 Canonical roots: `boot/`, `application/`, `domain/`, `adapters/`, `support/`; legacy locations relocate when touched.
- AR2 Controllers (adapters/in/web): translate HTTP to domain, delegate to one use case, return `ResponseEntity`; no repo calls, no business logic.
- AR3 Use cases (application/): transactional boundary, single command, orchestrate domain/ports.
- AR4 Domain (domain/): invariants/transformations, framework-free, no Spring imports.
- AR5 Adapters (adapters/out/): implement ports, persist validated models, no HTTP/web concerns.
- AR6 Favor composition over inheritance; constructor injection only; services stateless.
- TS1 Test coverage mandatory: new functionality requires tests before completion.
- TS2 Discovery-first: locate existing tests, follow patterns, reuse utilities before writing new.
- TS3 Assert observable behavior: test response shapes/outcomes, not internal invocations or string comparisons.
- TS4 Refactor-resilient: unchanged behavior = passing tests regardless of internal restructuring.
- TS5 Naming: integration tests end with `IT`; unit tests end with `Test`.
- VR1 Build: `make build` or `./gradlew build`; expect success.
- VR2 Tests: `make test` or `./gradlew test`; targeted runs use `--tests ClassName`.
- VR3 Runtime: `make run &`, hit `/actuator/health` and changed endpoints; then stop.
- TL1 Standard commands: `make run`, `make dev`, `make test`, `make build`, `make compose-up`, `make compose-down`.
- TL2 Docker: `docker compose up -d` for Qdrant vector store.
- TL3 Ingest: `curl -X POST http://localhost:8080/api/ingest -H "Content-Type: application/json" -d '{"url": "..."}'`.
- TL4 Stream test: `curl -N http://localhost:8080/api/chat/stream -H "Content-Type: application/json" -d '{"message": "..."}'`.
- TL5 Environment: `.env` for secrets (`GITHUB_TOKEN`, `QDRANT_URL`); never commit secrets.
- LM1 Do not change any LLM settings (provider, base URL, model, temperature, max tokens) without explicit written approval.
- LM2 Do not auto-fallback or regress models across providers; if rate-limited, surface error to user, never silently switch.
- LM3 Use values from environment variables and `application.properties` exactly as configured.
- LM4 Allowed: logging diagnostics, returning actionable error messages; not allowed: silently changing LLM behavior.
- MD1 No regex for HTML/Markdown processing; use proper parsers (Flexmark, DOM APIs, AST visitors).
- MD2 Structured data over string manipulation: parse to objects, transform, serialize.
- MD3 Idiomatic language patterns: use Java Streams, Optional, proper HTML APIs.
- MD4 Separation of concerns: backend handles structure, frontend handles presentation.
- MD5 Fail-safe defaults: graceful degradation when parsing fails; never crash on malformed input.
- ST1 Smooth streaming: TTFB < 200ms, streaming start < 500ms, 60fps animations.
- ST2 Event types: `text`, `citation`, `code`, `enrichment`, `suggestion`, `status`.
- ST3 Error handling: `onErrorContinue` for partial failures; never drop entire response on single failure.
- ST4 Heartbeats: maintain connection with periodic events during long operations.
- JD1 Javadocs mandatory on public/protected classes, methods, and enums; one sentence for simple elements, 2-3 for complex ones.
- JD2 Focus on "why" (purpose, rationale, constraints) over "what" (which code already shows); never restate method name as description.
- JD3 First sentence is the summary: complete sentence, present tense, third person ("Calculates...", "Returns...", "Stores...").
- JD4 Use `@param` only when name isn't self-documenting or constraints exist; use `@return` only for non-obvious return values.
- JD5 Include `@throws` for checked exceptions and runtime exceptions callers should handle; state the condition triggering each.
- JD6 Reference evidence: when logic derives from specs/docs, cite source inline (e.g., "Per RFC 7231 section 6.5.1" or "See Spring Framework docs: [topic]").
- JD7 Deprecations require both `@Deprecated` annotation and `@deprecated` Javadoc tag with migration path: `@deprecated Use {@link NewClass#newMethod} instead`.
- JD8 No filler phrases: ban "This method...", "This class...", "Gets the...", "Sets the...", "Returns the..."; start with verb or noun directly.
- ER1 Use exceptions for exceptional cases; avoid defensive checks on trusted inputs.
- ER2 Never catch and ignore; either handle meaningfully or propagate.
- ER3 Prefer specific exception types over generic `Exception` or `RuntimeException`.
- DP1 Avoid unnecessary dependencies and unused code.
- DP2 No `@deprecated` imports; this rule may not be suppressed.
- DP3 Deprecated code must be a thin shim extending its successor; no aliases, fallbacks, or alternate implementations.
- SRC1 Never make assumptions; if unsure, stop and verify.
- SRC2 For dependency code questions, inspect `~/.m2` JARs first; fallback to upstream GitHub; never answer without referencing code.
- SRC3 Inspect `~/.gradle/caches/` for dependency code in Gradle projects; verify actual implementation rather than assuming.
- DK1 Never source container images from Docker Hub; strictly use `public.ecr.aws/docker/library/` or other explicit non-hub registries.
