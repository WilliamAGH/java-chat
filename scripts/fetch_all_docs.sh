#!/bin/bash

# Consolidated Documentation Fetcher with Deduplication
# This script fetches all required documentation (Java 24/25, Spring ecosystem)
# and ensures no redundant downloads by checking existing files

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Centralized source URLs (single source of truth)
RES_PROPS="$SCRIPT_DIR/../src/main/resources/docs-sources.properties"
if [ -f "$RES_PROPS" ]; then
  # Export variables defined as KEY=VALUE in the properties file
  set -a
  # shellcheck source=/dev/null
  . "$RES_PROPS"
  set +a
fi
DOCS_ROOT="$SCRIPT_DIR/../data/docs"
LOG_FILE="$SCRIPT_DIR/../fetch_all_docs.log"

# Options
INCLUDE_QUICK="${INCLUDE_QUICK:-false}"
CLEAN_INCOMPLETE="${CLEAN_INCOMPLETE:-true}"
FORCE_REFRESH="${FORCE_REFRESH:-false}"
for arg in "$@"; do
    case $arg in
        --include-quick)
            INCLUDE_QUICK="true"
            ;;
        --no-clean)
            CLEAN_INCOMPLETE="false"
            ;;
        --force)
            FORCE_REFRESH="true"
            ;;
        --help|-h)
            echo "Usage: $0 [--include-quick] [--no-clean] [--force]"
            echo "  --include-quick : Also refresh small 'quick' doc mirrors"
            echo "  --no-clean      : Do not quarantine incomplete mirrors before refetch"
            echo "  --force         : Refresh even when mirrors look complete"
            exit 0
            ;;
        *)
            echo "Unknown option: $arg"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo "=============================================="
echo "Consolidated Documentation Fetcher"
echo "=============================================="
echo "Docs root: $DOCS_ROOT"
echo "Log file: $LOG_FILE"
echo ""

# Initialize log
echo "[$(date)] Starting consolidated documentation fetch" > "$LOG_FILE"

# Function to log messages
log() {
    echo "[$(date)] $1" >> "$LOG_FILE"
    echo -e "$1"
}

extract_meta_version() {
    local file_path="$1"
    if [ -z "$file_path" ] || [ ! -f "$file_path" ]; then
        echo ""
        return 0
    fi
    local line
    line="$(grep -E '<meta name="version" content="[^"]+"' "$file_path" 2>/dev/null | head -n 1 || true)"
    if [ -z "$line" ]; then
        echo ""
        return 0
    fi
    echo "$line" | sed -E 's/.*content="([^"]+)".*/\1/'
}

extract_javadoc_comment_version() {
    local file_path="$1"
    if [ -z "$file_path" ] || [ ! -f "$file_path" ]; then
        echo ""
        return 0
    fi
    local line
    line="$(grep -E '<!-- Generated by javadoc \\([0-9]+' "$file_path" 2>/dev/null | head -n 1 || true)"
    if [ -z "$line" ]; then
        echo ""
        return 0
    fi
    echo "$line" | sed -E 's/.*javadoc \\(([0-9]+)\\).*/\\1/'
}

count_html_files() {
    local dir="$1"
    if [ -d "$dir" ]; then
        find "$dir" -name "*.html" 2>/dev/null | wc -l | tr -d ' '
    else
        echo "0"
    fi
}

quarantine_incomplete_dir() {
    local dir="$1"
    local name="$2"
    local html_count="$3"
    local min_files="$4"

    if [ "$CLEAN_INCOMPLETE" != "true" ]; then
        return 0
    fi
    if [ ! -d "$dir" ]; then
        return 0
    fi
    if [ "$html_count" -ge "$min_files" ]; then
        return 0
    fi

    local quarantine_root="$DOCS_ROOT/.quarantine"
    local timestamp
    timestamp="$(date -u +%Y%m%d_%H%M%S)"
    mkdir -p "$quarantine_root"

    local base
    base="$(basename "$dir")"
    local quarantine_dir="$quarantine_root/${base}.${timestamp}"
    log "${YELLOW}âš  Quarantining incomplete mirror: $name ($html_count HTML files; expected $min_files+) -> $quarantine_dir${NC}"
    mv "$dir" "$quarantine_dir"
}

quarantine_path() {
    local dir="$1"
    local name="$2"

    if [ "$CLEAN_INCOMPLETE" != "true" ]; then
        return 0
    fi
    if [ -z "$dir" ] || [ ! -e "$dir" ]; then
        return 0
    fi

    local quarantine_root="$DOCS_ROOT/.quarantine"
    local timestamp
    timestamp="$(date -u +%Y%m%d_%H%M%S)"
    mkdir -p "$quarantine_root"

    local base
    base="$(basename "$dir")"
    local quarantine_dir="$quarantine_root/${base}.${timestamp}"
    log "${YELLOW}âš  Quarantining legacy mirror path: $name -> $quarantine_dir${NC}"
    mv "$dir" "$quarantine_dir"
}

quarantine_versioned_reference_subdirs() {
    local target_dir="$1"
    local name="$2"
    local allow_regex="${3:-}"

    if [ "$CLEAN_INCOMPLETE" != "true" ]; then
        return 0
    fi
    if [ -z "$target_dir" ] || [ ! -d "$target_dir/reference" ]; then
        return 0
    fi

    shopt -s nullglob
    local child
    for child in "$target_dir/reference/"*; do
        local child_base
        child_base="$(basename "$child")"
        if [ -n "$allow_regex" ] && [[ "$child_base" =~ $allow_regex ]]; then
            continue
        fi
        if [[ "$child_base" =~ ^[0-9] ]] || [[ "$child_base" == *SNAPSHOT* ]]; then
            quarantine_path "$child" "$name reference/$child_base"
        fi
    done
    shopt -u nullglob
}

# Function to fetch documentation with wget (incremental via timestamping)
fetch_docs() {
    local url="$1"
    local target_dir="$2"
    local name="$3"
    local cut_dirs="$4"
    local min_files="$5"
    local reject_regex="${6:-}"
    local allow_partial="${7:-false}"

    # Allow config-friendly placeholder for regex alternation without breaking our field delimiter.
    reject_regex="${reject_regex//__OR__/|}"

    local existing_count
    existing_count="$(count_html_files "$target_dir")"
    if [ "$existing_count" -gt 0 ]; then
        log "${BLUE}â„¹ Existing mirror: $existing_count HTML files${NC}"
    fi
    if [ "$allow_partial" != "true" ] && [ "$min_files" -gt 0 ] && [ "$existing_count" -gt 0 ] && [ "$existing_count" -lt "$min_files" ]; then
        quarantine_incomplete_dir "$target_dir" "$name" "$existing_count" "$min_files"
    fi

    # Proactive cleanup for known legacy Spring mirror layouts that otherwise mask incomplete fetches.
    if [[ "$name" == *"Spring Framework Javadoc"* ]]; then
        quarantine_path "$target_dir/api/current" "$name legacy api/current"
    fi
    if [[ "$name" == *"Spring Framework Reference"* ]]; then
        quarantine_versioned_reference_subdirs "$target_dir" "$name" ""
    fi
    if [[ "$name" == *"Spring AI Reference"* ]]; then
        quarantine_versioned_reference_subdirs "$target_dir" "$name" "^2\\."
    fi

    log "${YELLOW}Fetching $name...${NC}"
    mkdir -p "$target_dir"
    cd "$target_dir"

    # Oracle Javadoc: use an explicit seed list derived from the Javadoc search indices.
    # This avoids incomplete recursive crawls. To avoid 10k+ URL checks every run, only do this when
    # the local mirror is incomplete or when --force is set.
    if [[ "$url" == *"docs.oracle.com/en/java/javase/"*"/docs/api/" ]]; then
        if [ "$FORCE_REFRESH" != "true" ] && [ "$min_files" -gt 0 ] && [ "$existing_count" -ge "$min_files" ]; then
            log "${GREEN}âœ“ $name already fetched: $existing_count HTML files (minimum: $min_files)${NC}"
            return 0
        fi

        local seed_file="$target_dir/.oracle-javadoc-seed.txt"
        log "${BLUE}â„¹ Oracle Javadoc detected; generating explicit URL seed list...${NC}"
        python3 "$SCRIPT_DIR/oracle_javadoc_seed.py" --base-url "$url" --output "$seed_file" 2>&1 | tee -a "$LOG_FILE"
        local seed_url_count
        seed_url_count="$(wc -l "$seed_file" | awk '{print $1}')"
        log "${BLUE}â„¹ Oracle Javadoc seed URLs: $seed_url_count${NC}"

        local wget_seed_args=(
            --timestamping
            --no-host-directories
            --cut-dirs="$cut_dirs"
            --input-file="$seed_file"
            --directory-prefix="$target_dir"
            --show-progress
            --progress=bar:force
            --timeout=120
            --dns-timeout=30
            --connect-timeout=30
            --read-timeout=120
            --tries=5
            --waitretry=1
            --retry-connrefused
            --user-agent="java-chat-doc-fetcher/1.0"
        )

        wget "${wget_seed_args[@]}" 2>&1 | tee -a "$LOG_FILE"
        local seed_result=$?
        cd - > /dev/null

        local seed_count
        seed_count="$(count_html_files "$target_dir")"

        # wget returns 8 for HTTP errors (e.g., a few 404s) even when the mirror is usable.
        # Prefer our post-fetch validation over raw exit status.
        if [ $seed_result -ne 0 ] && [ $seed_result -ne 8 ]; then
            log "${RED}âœ— Failed to fetch $name (exit code: $seed_result)${NC}"
            return 1
        fi

        log "${GREEN}âœ“ $name fetched successfully: $seed_count HTML files${NC}"
        if [ "$min_files" -gt 0 ] && [ "$seed_count" -lt "$min_files" ] && [ "$allow_partial" != "true" ]; then
            log "${RED}âœ— $name mirror is still incomplete after fetch: $seed_count HTML files (expected $min_files+)${NC}"
            return 1
        elif [ "$min_files" -gt 0 ] && [ "$seed_count" -lt "$min_files" ] && [ "$allow_partial" = "true" ]; then
            log "${YELLOW}âš  $name mirror is still incomplete after fetch: $seed_count HTML files (expected $min_files+); keeping partial mirror for incremental reruns${NC}"
        fi
        return 0
    fi

    local wget_args=(
        --mirror \
        --convert-links \
        --adjust-extension \
        --page-requisites \
        --no-parent \
        --no-host-directories \
        --cut-dirs="$cut_dirs" \
        --reject="index.html?*" \
        --accept="*.html,*.css,*.js,*.png,*.gif,*.jpg,*.jpeg,*.svg,*.pdf,*.woff,*.woff2,*.ttf,*.eot" \
        --quiet \
        --show-progress \
        --progress=bar:force \
        --timeout=30 \
        --dns-timeout=30 \
        --connect-timeout=30 \
        --read-timeout=30 \
        --tries=3 \
        --waitretry=1 \
        --retry-connrefused \
        --no-verbose \
    )

    if [ -n "$reject_regex" ]; then
        wget_args+=(--reject-regex="$reject_regex")
    fi

    wget "${wget_args[@]}" "$url" 2>&1 | tee -a "$LOG_FILE"

    local result=$?
    cd - > /dev/null
    
    local count
    count="$(count_html_files "$target_dir")"

    # wget returns 8 for HTTP errors (e.g., a few 404s) even when the mirror is usable.
    # Prefer our post-fetch validation over raw exit status.
    if [ $result -ne 0 ] && [ $result -ne 8 ]; then
        log "${RED}âœ— Failed to fetch $name (exit code: $result)${NC}"
        return 1
    fi

    log "${GREEN}âœ“ $name fetched successfully: $count HTML files${NC}"
    if [ "$min_files" -gt 0 ] && [ "$count" -lt "$min_files" ] && [ "$allow_partial" != "true" ]; then
        log "${RED}âœ— $name mirror is still incomplete after fetch: $count HTML files (expected $min_files+)${NC}"
        return 1
    elif [ "$min_files" -gt 0 ] && [ "$count" -lt "$min_files" ] && [ "$allow_partial" = "true" ]; then
        log "${YELLOW}âš  $name mirror is still incomplete after fetch: $count HTML files (expected $min_files+); keeping partial mirror for incremental reruns${NC}"
    fi
    return 0
}

# Documentation sources configuration
# Format: URL|TARGET_DIR|NAME|CUT_DIRS|MIN_FILES|REJECT_REGEX|ALLOW_PARTIAL
DOC_SOURCES=(
    # Spring Boot (current)
    "${SPRING_BOOT_REFERENCE_BASE:-https://docs.spring.io/spring-boot/reference/}|$DOCS_ROOT/spring-boot-complete|Spring Boot Reference (current)|1|50|"
    "${SPRING_BOOT_API_BASE:-https://docs.spring.io/spring-boot/api/}|$DOCS_ROOT/spring-boot-complete|Spring Boot API (current)|1|7000|"

    # Spring AI
    # Stable reference (1.1.x) - avoid pulling versioned reference subtrees (including 2.0) and SNAPSHOT content.
    "${SPRING_AI_REFERENCE_BASE:-https://docs.spring.io/spring-ai/reference/}|$DOCS_ROOT/spring-ai-reference|Spring AI Reference (stable)|1|80|/spring-ai/reference/[0-9]__OR__/spring-ai/reference/[^/]*SNAPSHOT"
    # 2.0 reference (milestone) - avoid SNAPSHOT content.
    "${SPRING_AI_REFERENCE_2_BASE:-https://docs.spring.io/spring-ai/reference/2.0/}|$DOCS_ROOT/spring-ai-reference-2|Spring AI Reference (2.0)|1|80|/spring-ai/reference/[^/]*SNAPSHOT"
    # API docs (stable + 2.x). Keep these separate to avoid quarantine/validation conflicts.
    "${SPRING_AI_API_STABLE_BASE:-https://docs.spring.io/spring-ai/docs/current/api/}|$DOCS_ROOT/spring-ai-api-stable|Spring AI API (stable)|1|200|"
    "${SPRING_AI_API_2_BASE:-https://docs.spring.io/spring-ai/docs/2.0.x/api/}|$DOCS_ROOT/spring-ai-api-2|Spring AI API (2.x)|1|200|"

    # Spring Framework (current) - avoid pulling older reference versions under /reference/6.x, etc.
    "${SPRING_FRAMEWORK_REFERENCE_BASE:-https://docs.spring.io/spring-framework/reference/}|$DOCS_ROOT/spring-framework-complete|Spring Framework Reference (current)|1|3000|/spring-framework/reference/[0-9]__OR__/spring-framework/reference/[^/]*SNAPSHOT"
    "${SPRING_FRAMEWORK_API_BASE:-https://docs.spring.io/spring-framework/docs/current/javadoc-api/}|$DOCS_ROOT/spring-framework-complete|Spring Framework Javadoc (current)|1|7000|"

    "${JAVA25_RELEASE_NOTES_ISSUES_URL:-https://www.oracle.com/java/technologies/javase/25-relnote-issues.html}|$DOCS_ROOT/oracle/javase|Java 25 Release Notes Issues|3|1|"
    "${IBM_JAVA25_ARTICLE_URL:-https://developer.ibm.com/articles/java-whats-new-java25/}|$DOCS_ROOT/ibm/articles|IBM Java 25 Overview|1|1|"
    "${JETBRAINS_JAVA25_BLOG_URL:-https://blog.jetbrains.com/idea/2025/09/java-25-lts-and-intellij-idea/}|$DOCS_ROOT/jetbrains/idea/2025/09|JetBrains Java 25 Blog|3|1|"

    "${JAVA24_API_BASE:-https://docs.oracle.com/en/java/javase/24/docs/api/}|$DOCS_ROOT/java/java24-complete|Java 24 Complete API|5|9000||true"
    "${JAVA25_API_BASE:-https://docs.oracle.com/en/java/javase/25/docs/api/}|$DOCS_ROOT/java/java25-complete|Java 25 Documentation|5|9000||true"
)

if [ "$INCLUDE_QUICK" = "true" ]; then
    DOC_SOURCES+=(
        "${SPRING_BOOT_REFERENCE_BASE:-https://docs.spring.io/spring-boot/reference/}|$DOCS_ROOT/spring-boot|Spring Boot Quick (reference landing)|1|1|"
        "${SPRING_FRAMEWORK_REFERENCE_BASE:-https://docs.spring.io/spring-framework/reference/}|$DOCS_ROOT/spring-framework|Spring Framework Quick (reference landing)|1|1|/spring-framework/reference/[0-9]__OR__/spring-framework/reference/[^/]*SNAPSHOT"
        "${SPRING_AI_REFERENCE_BASE:-https://docs.spring.io/spring-ai/reference/}|$DOCS_ROOT/spring-ai|Spring AI Quick (reference landing)|1|1|/spring-ai/reference/[0-9]__OR__/spring-ai/reference/[^/]*SNAPSHOT"
        "${SPRING_AI_REFERENCE_2_BASE:-https://docs.spring.io/spring-ai/reference/2.0/}|$DOCS_ROOT/spring-ai-2|Spring AI Quick (2.0 landing)|1|1|/spring-ai/reference/[^/]*SNAPSHOT"
    )
fi

# Statistics
TOTAL_FETCHED=0
TOTAL_FAILED=0

echo ""
log "Starting documentation fetch process..."
echo "=============================================="

# Process each documentation source
for source in "${DOC_SOURCES[@]}"; do
    IFS='|' read -r url target_dir name cut_dirs min_files reject_regex allow_partial <<< "$source"
    
    echo ""
    log "Processing: $name"
    log "URL: $url"
    log "Target: $target_dir"
    
    if fetch_docs "$url" "$target_dir" "$name" "$cut_dirs" "$min_files" "${reject_regex:-}" "${allow_partial:-false}"; then
        ((TOTAL_FETCHED++))
    else
        ((TOTAL_FAILED++))
        log "${YELLOW}Warning: Failed to fetch $name, continuing with others...${NC}"
    fi
done

echo ""
echo "=============================================="
echo "Documentation Fetch Summary"
echo "=============================================="
log "ðŸ“Š Statistics:"
log "  - Newly fetched: $TOTAL_FETCHED"
log "  - Failed: $TOTAL_FAILED"
log "  - Include quick mirrors: $INCLUDE_QUICK"
log "  - Clean incomplete mirrors: $CLEAN_INCOMPLETE"

# Count total files
TOTAL_HTML=$(find "$DOCS_ROOT" -name "*.html" 2>/dev/null | wc -l | tr -d ' ')
TOTAL_FILES=$(find "$DOCS_ROOT" -type f 2>/dev/null | wc -l | tr -d ' ')

SPRING_BOOT_REFERENCE_VERSION="$(extract_meta_version "$DOCS_ROOT/spring-boot-complete/reference/index.html")"
SPRING_FRAMEWORK_REFERENCE_VERSION="$(extract_meta_version "$DOCS_ROOT/spring-framework-complete/reference/index.html")"
SPRING_AI_REFERENCE_STABLE_VERSION="$(extract_meta_version "$DOCS_ROOT/spring-ai-reference/reference/index.html")"
SPRING_AI_REFERENCE_2_VERSION="$(extract_meta_version "$DOCS_ROOT/spring-ai-reference-2/reference/2.0/index.html")"
JAVA24_JAVADOC_VERSION="$(extract_javadoc_comment_version "$DOCS_ROOT/java/java24-complete/api/index.html")"
JAVA25_JAVADOC_VERSION="$(extract_javadoc_comment_version "$DOCS_ROOT/java/java25-complete/api/index.html")"

log "  - Total HTML files: $TOTAL_HTML"
log "  - Total files: $TOTAL_FILES"
log "  - Documentation root: $DOCS_ROOT"

echo ""
log "${GREEN}âœ… Documentation fetch complete!${NC}"
log "Check log for details: $LOG_FILE"

# Create a marker file with fetch metadata
METADATA_FILE="$DOCS_ROOT/.fetch_metadata.json"
cat > "$METADATA_FILE" << EOF
{
  "last_fetch": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "statistics": {
    "newly_fetched": $TOTAL_FETCHED,
    "failed": $TOTAL_FAILED,
    "total_html_files": $TOTAL_HTML,
    "total_files": $TOTAL_FILES
  },
  "versions": {
    "java24_javadoc": "$(echo "$JAVA24_JAVADOC_VERSION")",
    "java25_javadoc": "$(echo "$JAVA25_JAVADOC_VERSION")",
    "spring_boot_reference": "$(echo "$SPRING_BOOT_REFERENCE_VERSION")",
    "spring_framework_reference": "$(echo "$SPRING_FRAMEWORK_REFERENCE_VERSION")",
    "spring_ai_reference_stable": "$(echo "$SPRING_AI_REFERENCE_STABLE_VERSION")",
    "spring_ai_reference_2": "$(echo "$SPRING_AI_REFERENCE_2_VERSION")"
  },
  "directories": {
    "java24_complete": "$(find "$DOCS_ROOT/java/java24-complete" -name "*.html" 2>/dev/null | wc -l | tr -d ' ')",
    "java25_complete": "$(find "$DOCS_ROOT/java/java25-complete" -name "*.html" 2>/dev/null | wc -l | tr -d ' ')",
    "spring_boot_complete": "$(find "$DOCS_ROOT/spring-boot-complete" -name "*.html" 2>/dev/null | wc -l | tr -d ' ')",
    "spring_framework_complete": "$(find "$DOCS_ROOT/spring-framework-complete" -name "*.html" 2>/dev/null | wc -l | tr -d ' ')",
    "spring_ai_reference_stable": "$(find "$DOCS_ROOT/spring-ai-reference" -name "*.html" 2>/dev/null | wc -l | tr -d ' ')",
    "spring_ai_reference_2": "$(find "$DOCS_ROOT/spring-ai-reference-2" -name "*.html" 2>/dev/null | wc -l | tr -d ' ')",
    "spring_ai_api_stable": "$(find "$DOCS_ROOT/spring-ai-api-stable" -name "*.html" 2>/dev/null | wc -l | tr -d ' ')",
    "spring_ai_api_2": "$(find "$DOCS_ROOT/spring-ai-api-2" -name "*.html" 2>/dev/null | wc -l | tr -d ' ')"
  }
}
EOF

log "Metadata saved to: $METADATA_FILE"
echo ""
echo "Next step: Run 'make run' or './scripts/process_all_to_qdrant.sh' to process and upload to Qdrant"
